<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用官方Wiki的方式安装ArchLinux（编写中）]]></title>
    <url>%2F2017%2F05%2F17%2Farch_install%2F</url>
    <content type="text"><![CDATA[写在前面 这可能是你能找到的最适合你的中文ArchLinux安装教程。 前几天硬盘挂了，万幸的是家目录放在了另一块硬盘上所以存活了下来。不得不再重装一遍Arch，算上帮朋友装的，这已经是我第四次安装Arch了。也想借此机会记录这个过程写一篇完全按照官方Wiki指导再加上Wiki上没有重点写出来但是安装过程中会遇到的一些问题的一篇不太一样的安装教程。 很多人提起起Arch的第一反应就是安装困难，这种困难有很多原因，也就是接下来我们将会面对的问题。 没有图形界面的引导：Arch只给我们提供了一个最小的环境，所有的安装操作都需要在命令行中完成，这对于不习惯命令行操作的人来说是最难以跨越的一个坎。许多发行版之所以可以流行开来就是因为他们提供了友好的、流程化的安装过程，这帮很多人解决了学习Linux的第一步：安装一个Linux。 预备知识的不足与缺乏查找并解决问题的能力：一些对于安装系统比较重要的知识例如系统引导、配置文件的编辑、简单的命令行操作等没有接触过，所以操作时往往摸不着头脑，一旦自己的操作结果与教程不符便不知道如何去解决遇到的问题。 缺乏合适的教程：安装Arch最好的也是最完备的教程就是官方的Installation guide与Wiki，虽然部分内容有中文版，但是中文的翻译有些时候会落后于英文版，不推荐完全依赖于中文Wiki。并且官方Wiki的写作方式更偏向于文档，没有我们所习惯的按步骤编排的安装过程，给不熟悉这种写作方式的同学造成了阅读与使用上的困难。国内的可以找到的教程往往都是时间比较久远，或是没有提及或是忽略了一些新手容易犯错误的地方。 本篇教程致力于与现有的Wiki保持一致，并且适当地加入一些适合初学者学习的链接，希望可以让阅读了这篇教程的同学可以提高自己利用现有及以后可能出现的新的Wiki内容的能力。 ArchLinux或者是Linux的优点就不在这里多说了，我相信打开这篇教程的同学一定可以从这样的过程中得到很多。 下面就正式开始我们的教程。 安装教程前期准备安装介质在安装之前我们先要准备一个安装介质，在这里只推荐U盘作为安装介质。 到https://www.archlinux.org/download/页面下方的中国镜像源中下载archlinux-**-x86_64.iso这个iso文件。 如果是Linux系统下制作安装介质，推荐使用dd命令，教程： http://blog.topspeedsnail.com/archives/404 如果是windows系统下制作安装介质，推荐使用usbwriter这款轻量级的工具，下载链接： https://sourceforge.net/projects/usbwriter/ 磁盘准备我们需要有一块空闲的磁盘区域来进行安装，这里的空闲指的是没有被分区的空间。下面来介绍如何准备这块空间。 在windows下空出一块分区来安装：利用windows自带的磁盘管理工具就可以： 右击windows图标，在弹出菜单中选择磁盘管理（其他版本的windows请自行找到打开磁盘管理的方式）： 右击想要删除的分区，选择删除卷（注意这步之后这个分区的所有数据将会丢失）： 在linux下分出一块区域安装：使用fdisk进行，教程请见链接中的删除分区： http://www.liusuping.com/ubuntu-linux/linux-fdisk-disk.html 空闲的磁盘（新磁盘）：不需要进行任何操作。 U盘安装下面的过程实际上都在刚刚准备好的U盘启动介质上的Linux系统下进行，所以启动时都应该选择U盘。 设置启动顺序这一步在不同品牌的电脑上都不一样，所以需要大家自行搜索自己电脑品牌+启动顺序这个关键词来进行设置。 例如我的电脑搜索神舟 启动顺序可以得到如下的结果： https://zhidao.baidu.com/question/170954184.html 一般来说现在的主板都可以不用进入BIOS而快速地切换启动顺序，只要找到相应的快捷键就可以了。 进入U盘下的Linux系统 按上一步设置好启动顺序，启动之后会看到如下界面： 如果直接进入windows，请检查启动顺序是否设置成功，U盘是否在制作启动介质时成功写入。 如果没有看到这个界面，请检查U盘是否制作成功，如果多次遇到问题可以考虑换一个U盘。 选择第一个选项。 这时Arch开始加载，你将会看到屏幕显示如下内容： 加载完成后你将会进入一个有命令提示符的界面： 如果出现FAIL或是其他错误信息导致无法启动请自行搜索错误信息来获得解决方法。 这就是Linux的终端界面了，接下来我们将通过在这个界面输入一系列命令来将Arch安装到我们的磁盘上。 下面进行的过程是按照官方Installation guide为依据进行的，出现的任何问题都可以到链接中的相应部分查找原文找到解决方式。 检查引导方式目前的引导方式主要分为EFI引导+GPT分区表与BIOS(LEGACY)引导+MBR分区表两种，几乎比较新的机器都采用了EFI/GPT引导的方式。关于这部分的内容如果有兴趣可以通过这个链接进行了解： http://www.chinaz.com/server/2016/1017/595444.shtml 如果你不知道自己的引导方式，请在命令提示符下输入以下命令： 1ls /sys/firmware/efi/efivars 这里的ls是命令，空格后面的一串为路径，作为ls命令的参数。ls命令的作用是显示路径目录下的所有的文件（夹）。 如果你对命令行下的常用操作（TAB补全、取消命令等）不熟悉，请先学习了解下面部分实用的快捷键或命令： Tab键 命令行自动补全。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配你键入字符的所有命令 ↑(Ctrl+p) 显示上一条命令 ↓(Ctrl+n) 显示下一条命令 Ctrl-C: 终止当前正在执行的命令 输入命令并回车运行后，如果提示 1ls: cannot access '/sys/firmware/efi/efivars': No such file or directory 表明你是以BIOS方式引导，否则为以EFI方式引导。现在只需要记住这个信息，之后会用到。 联网arch并不能离线安装，因为我们需要联网来下载需要的组件，所以我们首先要连接网络。 如果你是有线网并且路由器支持DHCP的话插上网线后应该已经是联网状态了，可以输入以下命令来进行判断： 1ping www.baidu.com 如果可以看到类似下面的内容就说明连上了网络： 再次提示用快捷键Ctrl-C可以终止当前正在执行的命令 如果你是无线网，请输入以下命令： 1wifi-menu 这是一个实用的命令行下联网工具，有字符形式的图形化界面，利用它可以方便地联网，如果它没能起作用，需要进入以下页面查找解决方式： https://wiki.archlinux.org/index.php/Wireless_network_configuration 连接以后同样可以通过上面的ping命令来进行测试。 更新系统时间输入如下命令： 1timedatectl set-ntp true 正常情况下这样的命令并没有输出，也就是没有消息就是最好的消息 分区与格式化特别注意：涉及到分区与格式化的操作要格外注意，命令在回车之前请再三确认知道自己在做什么，并且没有输错命令，否则将会来带来数据的丢失！如果有需要在操作之前请备份重要的数据。 但是我们也并不要过于惧怕分区与格式化过程，正确操作的情况下不会对你其他数据产生任何影响。 查看目前的分区情况输入命令： 1fdisk -l 以我的电脑为例： 可以看到我的一块238.5g的硬盘(/dev/sda就代表这块硬盘)，下面列出了/dev/sda*这三个分区，/dev/sda3是我存活下来的家目录，可以看到它的类型为Linux分区。注意看Start与End的数值，这个数值代表扇区号，可以理解成硬盘被划分成了一个个小单元，可以直观地看出来在/dev/sda2的End与/dev/sda3的Start之间空出了一大块未分配的空间，接下来我们将分配这块区域。 如果你是BIOS/MBR方式引导，跳过下面创建一个引导分区的步骤。 如果你是EFI/GPT方式引导，并且同时安装了其他系统，那么你应该可以在分区列表中发现一个较小的并且类型为EFI的分区，这是你的引导分区，请记下它的路径（/dev/sd..)备用，跳过下面创建一个引导分区的步骤。 如果你是EFI/GPT方式引导，但是没有这个较小的并且类型为EFI的引导分区（这种情况一般只会出现在新的硬盘），那么你需要先创建一个引导分区。 创建一个引导分区（仅上面所列的第三种情况需要进行这步）输入命令： 1fdisk /dev/sda （请将sda替换成你要操作的磁盘如sdb sdc等） 下面你就进入了fdisk的操作环境， 输入m并回车可以查看各命令的作用。 如果你是一块全新的硬盘，输入g来创建一个全新的gpt分区表。 输入n创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，这里我们输入+512M来创建一个512M的引导分区。 这时我们可以输入p来查看新创建的分区。 输入t并选择新创建的分区序号来更改分区的类型，输入l可以查看所有支持的类型，输入ef更改分区的类型为EFI。 输入w来将之前所有的操作写入磁盘生效，在这之前可以输入p来确认自己的分区表没有错误。 输入以下命令来格式化刚刚创建的引导分区： 1mkfs.fat -F32 /dev/sdxY （请将的sdxY替换为刚创建的分区） 现在引导分区就创建好了。 创建根分区输入命令： 1fdisk /dev/sda （请将sda替换成你要操作的磁盘如sdb sdc等） 如果你是一块全新的硬盘，输入o来创建一个新的MBR分区表。 输入n创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，如果我们想要使创建的分区完全占满空闲的空间，可以直接回车使用默认结束扇区。 这时我们可以输入p来查看新创建的分区。 输入w来将之前所有的操作写入磁盘生效，在这之前可以输入p来确认自己的分区表没有错误。 输入以下命令来格式化刚刚创建的根分区： 1mkfs.ext4 /dev/sdxY （请将的sdxY替换为刚创建的分区） 这是我的分区过程供参考：]]></content>
      <categories>
        <category>Linux</category>
        <category>Arch</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android利用UDP、TCP进行局域网数据传输]]></title>
    <url>%2F2017%2F05%2F11%2Fandroid_lan_messages%2F</url>
    <content type="text"><![CDATA[写在前面在团队内部的hackweek中实现了一个在局域网环境中（同一个wifi下）进行的卡片收发小游戏，踩了一些关于局域网内通信的坑，这篇博文就用来整理一下整个过程的思路，完整代码地址。 实现思路在整个过程中利用到了UDP与TCP两种传输层协议，两者的特性决定了使用上的不同。 简单地说，UDP非面向连接，不需要先与目标建立连接，所以UDP不提供可靠的数据传输，也不能保证数据准确无误地到达目的地，但UDP的优势在于它可以迅速传送大量信息，传输性能比较好。 而TCP是面向连接的协议，需要经过三次握手与目的地址建立一个稳定的连接，可以保证数据准确、完整地到达。但是它的传输效率就没有UDP那么高。 首先，为了数据传输的稳定和准确性，在传送主要数据部分我们必需使用TCP来建立一个点对点的稳定的连接来传输主要数据。 但是，为了建立一个TCP连接，请求的一方必须要知道被请求一方（下面简称服务方）的IP地址。而在局域网中，如果我们想要实现每个人连接局域网以后马上可以收发信息，由于每次加入时分配到的IP地址并不是固定的也无法提前得知，所以我们需要使用其他的办法先获取到服务方的IP地址。 这时就要利用到UDP协议的组播特性了，组播可以让设备都加入一个预设好的组，然后就可以向这个组中发送数据包，只要加入了这个组的设备都可以收到这个数据包。这样只要所有的设备都提前加入了同一个组，不需要互相知道IP地址就可以交换数据，那么我们应该如何利用这样的特性呢？ 结合我们的实际需求，游戏过程是每个人可以向所有人发送一个只有标题的匿名卡片（这个过程就符合UDP组播的特性），如果感兴趣的人就可以点击收到的卡片来打开这个卡片查看具体内容（这个过程就需要我们建立TCP连接来传输数据）。 所以我们就有了思路，向所有人发送卡片的过程使用UDP进行组播，数据包中除了包含标题信息还要包含一个发送人的IP地址以及一个Mac地址作为ID（考虑到重新连接后地址发生改变的问题），当所有人收到这个卡片以后需要建立连接的时候就可以得到发送人的IP来进行TCP连接。 下面我们来实现这个过程。 具体实现组播我们定义一个ComUtil类来处理组播 加入组12345678910111213public static final String CHARSET = "utf-8";private static final String BROADCAST_IP = "224.0.1.2"; //IP协议中特殊IP地址，作为一个组，用来集合加入的所有客户端public static final int BROADCAST_PORT = 7816; //广播目的端的端口号private static final int DATA_LEN = 4096;private MulticastSocket socket = null;private InetAddress broadcastAddress = null;//当前设备在局域网下的IP地址byte[] inBuff = new byte[DATA_LEN];private DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length);//用于接受对象的packetprivate DatagramPacket outPacket = null;//用于发送对象的packetprivate Handler handler;public ComUtil(Handler handler) &#123; this.handler = handler;//回调使用Handler机制&#125; 12345678910111213public void startReceiveMsg() &#123; try &#123; socket = new MulticastSocket(BROADCAST_PORT);//打开一个组播Socket broadcastAddress = InetAddress.getByName(BROADCAST_IP);//需要进行一步转换来使用String类型的IP地址 socket.joinGroup(broadcastAddress);//加入一个组 outPacket = new DatagramPacket(new byte[0], 0, broadcastAddress, BROADCAST_PORT);//用于发送数据包的DatagramPacket &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //下面两行用于下文中的开始接收广播 Thread thread = new Thread(new ReadBroad()); thread.start();&#125; 注释应该讲得比较清楚了，这里要注意的是UDP数据的收发需要使用一个DatagramPacket来进行。可以理解为一个数据包。 接收组播信息上面的代码最后两行新建了一个线程用于接收组播信息，具体代码如下： 123456789101112131415class ReadBroad implements Runnable &#123; public void run() &#123; while (true) &#123; try &#123; socket.receive(inPacket); Message message = new Message(); message.what = BROADCAST_PORT; message.obj = inBuff; handler.sendMessage(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 进行了一个无限循环，进行到第5行时如果没有收到广播的DatagramPacket会一直处于阻塞状态，收到一个DatagramPacket后就会通过Handler来转发出去，在Handler所在线程来处理这个数据包。之后再进行循环不断地接收并处理数据包。 发送组播信息123456789101112131415161718public void broadCast(final byte[] msg) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; outPacket.setData(msg); //数据来源为外部，类型是二进制数据 socket.send(outPacket);//向组中发送该数据包 &#125; catch (IOException ex) &#123; ex.printStackTrace(); if (socket != null) &#123; socket.close(); &#125; &#125; &#125; &#125;); thread.start();&#125; 这个方法由外部调用，传入一个二进制数组数据通过setData()放在数据包中向组中的所有成员发送。成员通过上一节的接收方法接收到的就会是同样的数据包。 数据处理建立了组播的工具，下一步就要建立一个数据对象来进行信息的交换。由于数据包中的数据只能是以字节码的形式存在，所以我们设计的数据对象一定要是可序列化的（也就是实现了Serializable接口的），再通过流工具进行转换。 1234567public class UDPDataPackage implements Serializable &#123; private String ipAddress; private String macAddress; private String title; private String id; ...&#125; 在这个简单的JavaBean中只定义了四个简单数据。 我们将自己的信息设置后就可以通过如下方法转换成一个字节数组再通过上面的广播方法来发送： 1comUtil.broadCast(ConvertData.objectToByte(new UDPDataPackage(...))); //发送数据 123456789101112//通过流来进行的序列化public static byte[] objectToByte(Object object) &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream outputStream; try &#123; outputStream = new ObjectOutputStream(byteArrayOutputStream); outputStream.writeObject(object); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return byteArrayOutputStream.toByteArray();&#125; 同样的，在接收到数据以后可以反序列化来得到原对象： 1234567891011public static Object byteToObject(byte[] bytes) &#123; ByteArrayInputStream byteInputStream = new ByteArrayInputStream(bytes); Object object = null; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(byteInputStream); object = objectInputStream.readObject(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return object;&#125; 这样，我们就可以从这个对象中获取想到的IP地址等信息了。 建立TCP连接传输数据想要建立TCP连接，需要客户端与服务端两端的配合，我们现在已经获取到了需要建立连接的IP地址，下面我们要做的是与这个地址的服务端建立连接再传输数据。服务端需要一直运行来随时准备接受可能的请求。 由于我们同一个设备既要作为客户端，也要作为服务端，所以要编写两个类。 服务端12345public void startServer(Handler handler) &#123; this.handler = handler;//利用handler进行处理 thread = new Thread(new RunServer()); thread.start();//另开一个线程接收连接请求&#125; 1234567891011121314151617181920212223242526272829303132333435class RunServer implements Runnable &#123; @Override public void run() &#123; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket();//初始化一个ServerSocket serverSocket.setReuseAddress(true); serverSocket.bind(new InetSocketAddress(SERVER_PORT));//与端口绑定 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; while (true) &#123; try &#123; Socket socket = serverSocket.accept();//利用accept方法获得socket InputStream inputStream; inputStream = socket.getInputStream();//获取输入流（来源自客户端） ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);//转换为对象输入流 //获取udpDataPackage对象 UDPDataPackage udpDataPackage = (UDPDataPackage) objectInputStream.readObject(); OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(udpDataPackage);//将数据包写入输出流传送给客户端 objectOutputStream.flush();//刷新流 objectOutputStream.close(); outputStream.close(); objectInputStream.close(); inputStream.close(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 解释见注释。 客户端1234567public void sendRequest(String ipAddress, UDPDataPackage udpDataPackage, Handler handler) &#123; this.ipAddress = ipAddress;//即为之前获取到的IP地址 this.udpDataPackage = udpDataPackage; this.handler = handler; thread = new Thread(new SendData()); thread.start();&#125; 12345678910111213141516171819202122232425262728293031323334class SendData implements Runnable &#123; @Override public void run() &#123; Socket socket = null; try &#123; socket = new Socket(ipAddress, SERVER_PORT);//新建一个socket socket.setReuseAddress(true); socket.setKeepAlive(true);//设置socket属性 socket.setSoTimeout(5000);//设置超时 //获得一个对象输出流 OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(udpDataPackage);//将请求包写入输出流（传送给服务端） //获取服务端返回的流 InputStream inputStream = socket.getInputStream(); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); udpDataPackage dataPackage = (udpDataPackage) objectInputStream.readObject();//获取到返回的数据对象 //转发给handler进行处理 Message msg = new Message(); msg.what = SERVER_PORT; msg.obj = dataPackage; handler.sendMessage(msg); &#125; catch (SocketTimeoutException e) &#123; try &#123; if (socket != null) socket.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; sendRequest(ipAddress, udpDataPackage, handler); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 解释见注释。 可以看见TCP连接还是比较简单的，设置好socket并获取到输入输出流以后就可以把服务端当作本地流一样操作，具体的网络通信实现过程被隐藏了，有了流以后就可以进行所有能对流进行的操作了。到这里，我们要实现的局域网数据传输已经完成了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[王爽汇编语言第三版实验9 双循环实现]]></title>
    <url>%2F2017%2F04%2F10%2Fassembly_wang_lab_9%2F</url>
    <content type="text"><![CDATA[编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串welcome to masm!。 效果图： 采用了双循环嵌套的写法，外层控制输出行数，内层逐字符读取ASCII码与对应行的属性。 把loop s1改为loop s2有惊喜哦 所有实验答案在这里 123456789101112131415161718192021222324252627282930313233343536373839assume cs:code,ss:datacode segment mov ax,0b800h mov ds,ax mov bx,1760 mov ax,data mov ss,ax mov si,0 mov bp,0 mov cx,3s1: mov ss:[19],cx mov si,0 mov cx,16s2: mov di,si add di,di mov al,ss:[si] mov [bx+64+di],al mov al,ss:[16+bp] mov [bx+65+di],al inc si loop s2 inc bp add bx,160 mov cx,ss:[19] loop s1 mov ax,4c00h int 21hcode endsdata segment db &apos;welcome to masm!&apos; db 00000010b,00100100b,01110001b dw 0data endsend]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android PropertyAnimation 属性动画（二）弹跳小球实例]]></title>
    <url>%2F2017%2F04%2F02%2Fandroid_property_animation_2%2F</url>
    <content type="text"><![CDATA[前言GitHub完整代码 上篇博客简单介绍了属性动画的原理，这篇博客将会以一个简单的实例来运用上之前讲的内容，并对Animator的几个回调方法进行讲解。 目标是自定义一个View，在画布上绘制一个小球，点击屏幕后小球从顶部自由下落，落到底边后反弹，反弹损失一半的能量，也就是说小球只能上升到下落时一半的高度，再重复这个过程直到退出程序。如图： 创建自定义View首先我们要创建一个自定义View，这里我就采用继承LinearLayout的方式来创建这个View，但要注意LinearLayout默认是不绘制自身的，需要在onDraw()方法之前适当的时候调用setWillNotDraw(false);令其进行绘制。 在继承LinearLayout的同时我们要实现全部三个构造方法，否则xml文件的预览解析会出现问题： 1234567891011public VView(Context context) &#123; super(context);&#125;public VView(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125;public VView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125; 创建好自定义View后，我们就可以在对应的layout xml布局文件中用完整包名+类名的方式使用我们的自定义View： 1234&lt;com.viseator.viewtest.VView android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 同时，我们在绘制之前的onMeasure()方法中调用setWillNotDraw(false);使自定义View可以绘制： 123456@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setWillNotDraw(false); setOnClickListener(this); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; 这里也调用了setOnClickListener()注册之后的点击事件。 绘制小球的绘制1234567891011121314151617181920private ValueAnimator animator;public static final int radius = 50;private int xPos = radius;private int yPos = radius;private Paint paint = new Paint();@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (animator == null) &#123; canvasHeight = canvas.getHeight() - radius; paint.setColor(getResources().getColor(R.color.Gray)); paint.setAntiAlias(true); &#125; drawCircle(canvas);&#125;void drawCircle(Canvas canvas) &#123; canvas.drawCircle(xPos, yPos, radius, paint);&#125; 这里第10行对是否是第一次绘制进行判断并将画布大小保存到canvasHeight供之后的绘制使用（之后的绘制的坐标需要相对于画布的坐标）并设置paint的属性。 drawCircle()方法也非常简单，只是调用canvas提供的drawCircle()方法指定位置与半径和之前设置的paint，调用后就会在屏幕上的对应位置绘制一个小球。 下落动画的绘制下面就要让小球“动”起来，其实并不是小球发生了移动，只是我们不停地改变小球绘制的位置，当绘制的速率（帧率）大于24帧时的，就在视觉上变成了流畅的动画。也就是说，我们需要使用Animator连续地改变小球的位置，为了实现加速的效果，位置的改变速率应该随时间增加，也就是需要我们上一篇博客提到的Evaluator来实现。 animator的初始化123456789void init(int start, int end) &#123; animator = ValueAnimator.ofInt(start, end); animator.setDuration(1000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setRepeatMode(ValueAnimator.RESTART); animator.setInterpolator(new AccelerateInterpolator(rate)); animator.addUpdateListener(this); animator.addListener(this);&#125; 写成一个初始化方法便于重新初始化。 第2行将传入的值区间的开始与结束值作为参数获得了一个值为int的ValueAnimator。 第3行设置了动画的时间为1秒。 第4、5行分别设置了动画的重复次数为无限次，重复模式为重新开始，顾名思义，动画可以重复进行，重新开始的重复模式意味着一次动画结束之后数值重新从start到end进行改变，也可以设置重复的模式为反向，即一次动画结束之后数值从end到start变化。 第六行为animator设置了一个库中提供的AccelerateInterpolator即加速插值器，这就是我们实现加速效果的关键，上篇之中已经看过它的源码，默认时返回的最终动画进行百分比是时间百分比的平方，达到了位置随着时间的平方变化，也就是实现了加速下落的效果。 第7、8两行分别为animator设置了一个UpdateListener用于监听数值变化，一个Listener用于监听animator本身开始、停止、重复。 完成下落动画创建好了ValueAnimator，下一步就是在适合的时候在画布上重新绘制位置参数被animator改变后的小球。注意到我们之前小球的y坐标存储在yPos变量中，我们只要适时令yPos等于改变后的值再通过invalidate()方法进入onDraw()方法让View按小球的参数重新进行绘制就可以了。 animator的ValueAnimator.AnimatorUpdateListener为我们提供了一个及时刷新View的时机，之前为animator注册一个UpdateListener之后，每当animator的值发生改变时，onAniamtionUpdate()就会被回调。 那我们就可以在这个回调方法中为yPos设置新的值并令View重新绘制： 12345@Overridepublic void onAnimationUpdate(ValueAnimator animation) &#123; yPos = (int) animation.getAnimatedValue(); invalidate();&#125; 这样，我们只要启动animator令它的值开始变化，就会不断地调用onAnimationUpdate()重绘View： 123456@Overridepublic void onClick(View v) &#123; init(radius, canvasHeight); animationHeight = canvasHeight + radius; animator.start();&#125; start()方法令animator开始。 到这里，我们已经可以看到点击屏幕后小球下落到底部并停止的效果。 回弹效果实现我们之前已经为animator设置了无限重复，并且模式为重新开始，那么要做到回弹的效果，就要在小球落到底边（动画完成）之后，为小球设置新的初始值与最终值，让小球从最低点回到落下时一半的高度。高度数据我们在onClick()中的第4行（上面代码）已经初始化为了相对于画布的高度，之后再使用时只需把它除2就可以表示圆心距底边的高度了。 Animator.AnimatorListener为我们提供了一系列方法用于监听animator状态的变化（而不是数值）： （除金色为Android 8新增外）依次为动画取消，动画结束，动画开始重复，动画开始。 这里我们就需要在onAnimationReapt()回调中为动画设置新的初值与结束数值： 123456789101112131415@Overridepublic void onAnimationRepeat(Animator animation) &#123; ValueAnimator vAnimation = (ValueAnimator) animation; if (isDown) &#123; animationHeight = (int) (animationHeight * 0.5); &#125; isDown = !isDown; if (isDown) &#123; vAnimation.setIntValues(canvasHeight - animationHeight, canvasHeight); vAnimation.setInterpolator(new AccelerateInterpolator()); &#125; else &#123; vAnimation.setIntValues(canvasHeight, canvasHeight - animationHeight); vAnimation.setInterpolator(new DecelerateInterpolator()); &#125;&#125; 回调参数中的animation就是回调这个函数的animator，第3行对其进行一个类型转换。 这里我们使用了一个isDown参数来判断是否是下落过程，如果上个动画是下落过程，就将animationHeight减半。 第7行把isDown置反，再根据isDown的判断使用setIntValues()方法为animator设置新的范围，使用setInterpolator()方法设置新的插值器，注意上升时使用的应该是DecelerateInterpolater减速上升。 这样在新的动画开始时属性改变的范围就得到了改变，也就使得小球可以反弹了。 为了让每一次点击时动画都可以重新开始，在onClick()方法中加入几行初始化代码： 12345678910@Overridepublic void onClick(View v) &#123; if (animator != null) &#123; animator.end(); &#125; init(radius, canvasHeight); animationHeight = canvasHeight + radius; isDown = true; animator.start();&#125; 这里第3-5行让如果存在的animator停止，否则新动画无法启动。 下篇博客将会从源码角度继续探索animator的实现原理和更高级的一些特性。 GitHub完整代码]]></content>
      <categories>
        <category>Android</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android PropertyAnimation 属性动画（一）初探]]></title>
    <url>%2F2017%2F03%2F26%2Fandroid_property_animation_1%2F</url>
    <content type="text"><![CDATA[前言相对于静态的页面，动画往往能更直观地表达所需的信息，在UI开发过程中起着相当大的作用。 Android为我们提供了一系列实现动画效果的方法，PropertyAnimaiton是最常见也是最实用的一种，如同它的名字一样，它的实现方式是通过改变对象的一系列属性值来改变对象的状态， 例如动态地改变绘制的位置就可以实现绘制物体的移动效果，动态地改变对象的显示状态可以实现闪烁效果。 Animator概览Android提供的实现属性动画的工具是android.animation.Animator这个类，它的使用需要配合animation包下的其他工具类，这个类的功能是什么，我们要如何使用它来实现属性动画呢？ 我们可以将Animator理解为Android为我们提供的一个按我们的需要在一定时间段内连续地计算并返回值的工具，这个值可以是通用的整型、浮点型，也可以是我们自定义的类型。 我们可以设置返回值的范围，并可以控制值变化的快慢，例如实现自由落体下落的物体时我们需要让高度值以一个越来越快的速度降低。 这里的连续需要注意，实际上是不可能产生真正意义上的连续值的，但是如果在绘制过程中计算这个值的速度小于绘制一帧所需要的时间，那么我们就可以在视觉上认为这个值是在连续改变的。这一点也是理解其作用的关键：我们很难去写出一个可以随时获取连续值的工具，而Animator正是一个满足我们这个需求的一个通用工具。 通过将Animator与View的绘制过程结合，就可以实现绝大多数的动画效果， 但是Animator也不只局限在使用在绘制动画，只要是有相似需求的地方都可以使用它来实现， 同时由于属性动画只针对属性进行修改，与被修改对象之前几乎没有耦合，不需要对被修改对象作出改变，可以设置方式也多种多样，这些都是动画的另一种实现方法ViewAnimator所无法做到的，所以我属性动画是现在实现动画效果的普遍做法。 使用AnimatorAnimator子类下面就来看看如何使用Animator满足我们的需求。 我们使用Animator可以分为两个步骤，一是进行数值的计算，二是将计算出的数值设置到对应的对象上。而Animator有着三个子类：ValueAnimator ObjectAnimator AnimatorSet。 ValueAnimator实现了上述过程的第一个步骤：进行数值的计算。第二个步骤则需要我们重写它的回调在值发生改变时候手动地为对象更新属性值。 ObjectAnimator则在其基础上进行了进一步的封装，加入了一些方法使得它可以绑定一个对象，在数值改变的同时对对象的属性进行更新。 AnimatorSet可以对Animator进行组合，让它们之间进行联动，例如可以设置一个动画根据另一个动画的状态来决定是否开始、暂停或停止。 可以看到，ValueAnimator提供了一个Animator最核心的内容，也是使用中最为灵活的一个。ObjectAnimator由于绑定了相应的对象，在使用上会受一些限制。AnimatorSet专用于需要组合动画的场景。 ValueAnimator在这篇博客中，我们关注最为核心的ValueAnimator。 关键属性ValueAnimator对象内部维护了一系列属性来保存所需的各种信息。 Duration：动画的持续时间，通过setDuration()方法设置 Repeat count and behavior：重复计数与重复模式，我们可以通过设置这两个属性来控制动画是否重复以及重复的次数，通过setRepeatCount()与setRepeatMode()方法设置 Frame refresh delay：帧刷新延迟，也就是计算两帧动画之间的间隔时间，但这个时间只是Animator尽力去保持的值，具体的间隔时间会由于系统负载与性能的不同而不同，同时设置它的方法为一个静态方法：ValueAnimator.setFrameDelay()，会被设置到所有的Animator上，这是因为这些Animator都在同一个时间循环中。这个属性也有可能会被忽略如果动画系统采用了内部的计时来源，例如vsync来计算属性。同时这个方法需要在与start()方法相同的进程中调用 Time interpolation：时间插值器，是我们实现不同动画效果的关键，每一时刻所返回的数值由它决定，后文会详细讲 初始化与TypeEvaluatorValueAnimator对象的构造函数只由内部使用，获取ValueAnimator对象的方法是调用它的工厂方法： ValueAnimator.ofArgb() ValueAnimator.ofInt() ValueAnimator.ofFloat() ValueAnimator.ofObject() ValueAnimator.ofPropertyValuesHolder() //本篇未涉及，下一篇进行讲解 前三个可以看作是ValueAnimator为我们提供的初始化方式，它们的参数都是对应类型的长度可变参数:(Type ...values)，我们需要提供一个以上的参数，ValueAnimator最终提供的值会在这些值之前变动。 一般情况下这里提供的Argb（用于颜色值的变化）和整型、浮点值基本可以满足我们的需求，但是某些时候我们需要结果是我们自定义的一些对象，这个时候就需要用到TypeEvaluator&lt;&gt;接口了，与这个接口对应的工厂方法是ValueAnimator.ofObject()： 12ValueAnimator ofObject (TypeEvaluator evaluator, Object... values) 这里的可变参数类型变为了Object，同时还需要我们提供一个TypeEvaluator&lt;&gt;，用于“告诉”Animator如何返回这个Object值。 TypeEvaluator&lt;&gt;接口并不复杂，只有一个方法需要我们重写： 123T evaluate (float fraction, T startValue, T endValue) startValue与endValue非常好理解，就是我们在获取Animator时指定的值的起始值和结束值。类型与返回类型一致，当然都是我们自定义的类型。 这里的fraction就是决定我们最终返回值的关键参数。我们可以把这个fraction理解为animator提供给我们的最终的数值改变的比例，以小数表示，小于0表示低于startValue，大于0表示超出endValue，0-1之间表示在startValue与endValue之间。我们要做的就是把这个值转换为在起始和结果范围之间的合适的对象值。 例如，对于基本的浮点类型，默认的FloatEvaluator是这样的： 1234public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat);&#125; 可以看到，就是相当于把fraction所表示的比例“投射”到了我们所需要的数据对象上，这里是浮点类型。如果使用我们的自定义类型，我们必须为自己的类型定义这样的操作。 注意：这里要求我们必须将fraction线性地反应到对应的类型上，因为fraction反映的是最终的动画进度，我们必须如实地按照这个进度改变我们的属性，所以需要将result = x0 + t * (x1 - x0)`这样的形式反映到我们自己的对象上。 自定义了TypeEvaluator以后就可以作为参数使用在上面的obObject()工厂方法中了。 插补细分器(Interpolators)下面介绍使用ValueAnimator控制值变化过程中最为重要的一个概念：插补细分器(Interpolators)。 它实际上是一个关于时间的函数， 根据时刻的不同来返回不同的值，进而来控制最后的输出的值。那么它是如何表示的呢？ 系统为我们提供了一系列预置的Interpolators，以较常用的LinearInterpolater为例，顾名思义，它是一个线性的插补细分器，意味着输入与输出呈线性关系： 123public float getInterpolation(float input) &#123; return input;&#125; 输入输出的关键函数就是这个getInterpolation()了，可以看到，参数与返回值都是float类型，input的值在0-1之间，结合前面，我们可以很容易理解，这个input就是一个以0-1之间的小数表示的过去的时间值，例如整个动画是1000ms，当input为0.25的时候意味着现在的时间过去了250ms。 而返回值就是经过我们的转换，表示出的动画应该进行的时间的比例，这里由于是线性的，所以可以直接返回input，这个值最后会到哪里呢？自然就是给我们前面介绍的TypeEvaluator。下面一段源码展示了这个过程： 12345if (mInterpolator != null) &#123; fraction = mInterpolator.getInterpolation(fraction);&#125;return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue()); 作为getInterpolation()参数的fraction代表着过去的时间比例，这里调用我们设置的Interpolator来更新这个fraction，现在这个fraction表示的就是动画已经进行的比例，下一步就要根据它来获取对应的对象值（调用了我们之间谈到过的evaluate()方法，这里的KeyFrame的概念会在之后的博客讲到），后面的两个参数就是传递给evaluate的起始与结束范围。 最终，我们就获得了一个按照我们设定的Interpolator返回的动画属性值。 如果想要实现加速效果呢？Android同样为我们提供了现成的AccelerateInterpolator： 1234567public float getInterpolation(float input) &#123; if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125;&#125; 同样很简洁，这里用到了mFactor与mDoubleFactor分别表示我们在构造函数里面设置的指数值： 1234public AccelerateInterpolator(float factor) &#123; mFactor = factor; mDoubleFactor = 2 * mFactor;&#125; 如果我们设置的为1，会返回input的平方，其他值则会返回input的mDoubleFactor次方，使得动画属性可以以不同的函数曲线形式变化。 如果我们要实现自己的Interpolator呢？只需要实现TimeInterpolator接口，这个接口只需要我们实现一个getInterpolation方法。我们可以根据input值返回不同的值来返回不同的值表示动画的进度。 注意：返回值的范围不一定要在0-1之间，小于0或大小1的值可以表示超出预设范围的目标值。 这篇博客到此结束，在下一篇博客中将会以一个绘制自由落体的弹跳小球的示例来演示如何使用Animator与介绍它的回调函数。]]></content>
      <categories>
        <category>Android</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习资源收集]]></title>
    <url>%2F2017%2F03%2F25%2Fresource_general%2F</url>
    <content type="text"><![CDATA[技术分类 资源类型 标题 链接 简介 C语言 书籍 C Primer Plus 链接 C语言推荐入门书籍 算法 网站 编程练习/算法练习/面试刷题 链接 在线编程及测试网站，体验良好，题目优秀，从易到难做 数据结构与算法分析 书籍 数据结构与算法分析：C语言描述 第2版 链接 数据结构与算法分析权威书籍 算法 书籍 算法 第4版 链接 算法学习推荐书籍，强烈建议配合网课(链接)进行学习 Java 书籍 Java核心技术 卷1：基础知识（原书第10版） 链接 Java语言推荐入门书籍 Java 书籍 Effective Java中文版（第2版） 链接 Java语言推荐进阶书籍 Java 书籍 Java核心技术 卷2：高级特性（原书第9版） 链接 Java语言推荐进阶书籍 生活 网站 V2EX 链接 程序员生活 计算机网络 书籍 计算机网络（第5版） 链接 计算机网络基础推荐书籍 操作系统 书籍 现代操作系统（原书第3版） 链接 操作系统推荐书籍 计算机网络 书籍 TCP/IP详解：卷1+卷2+卷3 链接 计算机网络进阶推荐书籍 Linux 公开课 Linux 入门基础 链接 Linux 入门基础 Android 博客 Android学习路线指南 链接 Android开发艺术探索一书的作者分享的安卓学习路线，供参考 Android 书籍 第一行代码 Android 第2版 链接 Android入门推荐书籍 Android 书籍 安卓Android开发艺术探索+Android群英传+源码设计模式解析 链接 Android进阶必读 计算机系统 书籍 深入理解计算机系统（原书第3版） 链接 理解计算机系统 汇编语言 书籍 汇编语言（第3版） 链接 汇编语言推荐书籍 汇编语言 博客 上面这本书的检测点与实验解析 链接 上面这本书的检测点与实验解析By2015级陈志浩 规范 书籍 重构 改善既有代码的设计 链接 改善代码质量的进阶书籍 Java 书籍 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） 链接 Java深入必读 Java 书籍 华章专业开发者丛书·Java并发编程实战 链接 Java并发编程推荐书籍 设计模式 书籍 O’Reilly：Head First设计模式（中文版） 链接 设计模式推荐书籍 iOS 书籍 Objective-C程序设计（第6版） 链接 Objective-C语言入门书籍 iOS 书籍 Objective-C基础教程(第2版) 链接 Objective-C语言入门书籍’ iOS 书籍 Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法 链接 Objective-C与iOS开发提高]]></content>
      <categories>
        <category>Resource</category>
      </categories>
      <tags>
        <tag>Resource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View绘制之onDraw过程与Canvas Bitmap]]></title>
    <url>%2F2017%2F03%2F12%2Fandroid_view_onDraw_canvas%2F</url>
    <content type="text"><![CDATA[draw()方法经过对View的测量与布局过程后，下面就到了真正的View绘制的过程了。这个过程从调用根View的draw()方法开始：（省略部分代码） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; 这段源码来自于View，过程非常清晰，执行了以下的步骤（如果需要）： 27-30行进行判断是否跳过注释中的第2、5步，通常情况跳过 22-24行，进行背景的绘制 32行，调用onDraw()方法进行自身的绘制 35行，调用dispatchDraw()方法，进行子View的绘制（调用子View的draw()方法），同时也表明了子View的绘制在自身之后这一顺序 43行，进行前景的绘制，一般为装饰组件，如滚动条等 dispatchDraw()方法onDraw()方法先不谈，看看dispatchDraw()方法做了什么，以ViewGroup为例：(省略部分代码) 12345678910111213@Overrideprotected void dispatchDraw(Canvas canvas) &#123; for (int i = 0; i &lt; childrenCount; i++) &#123; if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; &#125;&#125;protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 简单来看，依次调用了子View的draw()方法。所以对于有子View的ViewGroup， 我们需要重写这个方法来决定子View绘制的顺序。 Canvas Bitmap Surface间的联系背景与前景绘制的过程一般不由我们控制，自定义View时关键的内容就在onDraw()方法中。 你可能已经发现，在这些View绘制过程中的函数都具有一个参数Canvas，这个Canvas字面意义上为画布，那它实际上是什么，又在绘制过程中起着什么样的重要作用呢？ 我们可以把Canvas看作是系统给予我们的一个虚拟的对象，或者说是我们绘制图形的一个中介，Canvas具有一系列的方法可以供我们调用来直观地绘制图形，我们对于Canvas的所有操作都会被系统处理从而反映在屏幕上而不用我们去手动地决定哪一个像素应该显示什么颜色。 在Canvas背后则是一个Bitmap对象，我们的绘制实际上会反映在这个Bitmap上再交由系统来显示。如果我们需要自己创建一个Canvas，我们必须创建一个Bitmap对象作为Canvas的构造参数。例如： 12Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);Canvas c = new Canvas(b); 这样这个Canvas就会在指定的Bitmap上进行绘制，我们也可以通过Canvas的drawBitmap()方法来在指定的Bitmap上绘制。 那么问题来了，onDraw()方法给我们提供的这个Canvas是从哪里来的，为什么我们对它的操作可以反映到屏幕上？下面这张图便于我们去了解这个过程： 可以看到，我们的屏幕被分为了几个Window，每一个Window都有着自己的Surface，Surface具有两级缓存，每个缓存中存放着将要显示在屏幕上的像素数据，而当我们想要刷新屏幕显示新的内容时，对应的Surface将会读取缓存中的数据来进行更新。 onDraw()方法中的canvas就是在一个Surface显示完毕，将这个Surface锁定时由它返回的，在这个canvas上进行的操作就可以在下一次刷新屏幕时显示，但是实际上并不是由canvas直接写数据到它的Surface缓存中，这中间还有一个对象就是我们之前提到的Bitmap，Bitmap储存着的正是像素信息，而Surface返回的canvas中含有的就是一个指向Surface缓存的Bitmap。 梳理一下整个过程，我们需要做的是操作这个封装了一系列绘图方法的canvas，canvas将操作反映到内含的Bitmap上，Bitmap将数据反映给Surface的缓存，Surface在下一次刷新时读取缓存中的内容并显示到屏幕上。 这里还应注意的是每个Window有且仅有一个单继承（即只有一个根）的View树，View将会将Surface返回的canvas向下传递来让子View依次完成部分区域的绘制。 弄清楚这个canvas的来源之后，我们就可以放心地在用它来“作画”了。 onDraw()方法在onDraw()方法中我们可以对方法参数提供的canvas进行操作，绘制各种自定义的图形。 我们可以选择一个现有的View作为自定义View的父类，在它的onDraw()方法中一定要调用super.onDraw()来令它绘制本来的组件，我们可以在调用super.onDraw()之前或之后插入我们自己的代码，这取决你对绘制顺序的需要。 注意有些View如Linearlayout默认是不绘制自己的，也就是说它们并不会调用onDraw()方法，当我们需要继承这类View来进行自定义并进行绘制的话需要调用setWillNotDraw(false);。可以在onMeasure()方法中调用。 另一种方式是继承于View，可以更为自由地订制各种行为。 Canvas中封装了非常多的方法，下面列举一部分： drawArc)(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)：绘制椭圆 drawCircle)(float cx, float cy, float radius, Paint paint)：绘制圆形 drawColor)(int color)：对整个Canvas填充颜色 drawLine)(float startX, float startY, float stopX, float stopY, Paint paint)：绘制直线 drawLines)(float[] pts, int offset, int count, Paint paint)：绘制一系列直线 drawPicture)(Picture picture, Rect dst)：绘制一张图片 drawPoint)(float x, float y, Paint paint)：绘制一个点 drawPoints)(float[] pts, int offset, int count, Paint paint)：绘制一系列点 drawRect)(float left, float top, float right, float bottom, Paint paint)：绘制矩形 drawRoundRect)(RectF rect, float rx, float ry, Paint paint)：绘制圆角矩形 drawText)(CharSequence text, int start, int end, float x, float y, Paint paint)：绘制文字 drawTextOnPath)(String text, Path path, float hOffset, float vOffset, Paint paint)：沿路径绘制文字 方法的详细信息在官方文档中。 我们注意到，许多绘制方法都需要一个Paint参数， 这个Paint可以理解为系统为我们抽象出的一支画笔，我们所绘制的图形都是用这支画笔绘制出来的，当然因此我们就可以对画笔设置颜色、粗细等属性，我们甚至可以用setShader()方法为这个Paint设置一个Shader，来实现各种特殊的动态效果，Shader的使用需要另起一篇博客来讲。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View绘制之layout过程]]></title>
    <url>%2F2017%2F03%2F12%2Fandroid_view_onLayout%2F</url>
    <content type="text"><![CDATA[经过上一篇介绍的measure过程之后，各个View的尺寸信息已经存储在了每个View中，下面是layout过程，layout过程的目的是根据上一步中计算出的尺寸来正确设置各个View及其后代的位置。这个过程首先被调用的是View的layout()方法，layout()的方法签名是public void layout(int l, int t, int r, int b)，四个参数分别为左边界距父View左边界的距离，上边界距父View上边界的距离，右边界距父View左边界的距离，下边界距父View上边界的距离。 12boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); changed是用于传递给onLayout()方法的参数，它指示了布局是否被改变。 后面的表达式查看了父View的布局模式是否需要显示边框，如需要，调用的是setOpticalFrame()方法： 12345678910private boolean setOpticalFrame(int left, int top, int right, int bottom) &#123; Insets parentInsets = mParent instanceof View ? ((View) mParent).getOpticalInsets() : Insets.NONE; Insets childInsets = getOpticalInsets(); return setFrame( left + parentInsets.left - childInsets.left, top + parentInsets.top - childInsets.top, right + parentInsets.left + childInsets.right, bottom + parentInsets.top + childInsets.bottom);&#125; 可以看到这个方法读取了设置的边框值， 把原值加上边框值后还是调用了setFrame()方法。 setFrame()方法通过传入的参数确定了该View最终的位置以及尺寸。 可以看到，一个View最终显示在什么位置以及它的尺寸是由layout()方法决定的，onMeasure()方法只是将测量出的View期望具有的大小储存在View中。一般情况下，我们会根据储存的这个尺寸来作为设定的依据。 接下来layout()方法会调用onLayout()方法，（如果需要的话）我们需要重写这个方法来调用子View的layout()方法。所以决定子View如何显示的关键步骤就在这里，他们的位置和尺寸完全取决于这里调用它们的layout()方法时传入的参数。当然一般情况下我们会根据子View中的测量结果来设置这个值。这里拿FrameLayout这个需要处理子View的ViewGroup实例来举例： 1234@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125; 直接调用了layoutChildren()：（省略部分行） 123456789101112131415161718192021222324252627282930313233343536void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; 省略了与获取布局属性相关的代码，可以看到： 4-8行获取了父View的位置数据并在18-31行用于确定最终的位置数据 10-11行遍历了所有的子View 12-13行获取了子View中在上一步骤的测量过程中储存的宽和高，并用于第33行中设置最终的右边界与下边界 第33行调用子View的layout()方法]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View绘制之measure过程]]></title>
    <url>%2F2017%2F03%2F10%2Fandroid_view_onMeasure%2F</url>
    <content type="text"><![CDATA[上一篇博客简单地介绍了View绘制的生命周期， 从这篇博客开始将会对这个周期中一些有用的过程进行一个详细一些的介绍。这篇的主角就是在构造方法之后调用的measure过程。 为了演示，继承了TextView来实现一个自定义的View。注意这里继承的应该是android.support.v7.widget.AppCompatTextView这个类。同时为了xml文件的正常解析，我们需要实现View的三个构造方法。 1234567891011public VView(Context context) &#123; super(context);&#125;public VView(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125;public VView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125; 再通过完整包名的方法在xml布局文件中创建我们的View就可以直接显示了。 12345&lt;com.viseator.viewtest.VView android:layout_width="100dp" android:layout_height="100dp" android:background="@color/Gray" /&gt; 这里给了TextView一个背景颜色便于后面的观察。 下面就开始分析measure过程。 measure是一个自顶向下的过程，即父View会依次调用它的子View的measure()方法来对它的子View进行测量。 View的measure()方法最终会调用onMeasure()，真正的尺寸信息就是在onMeasure()方法中最终确定的。所以我们需要做的就是在自定义View中重写onMeasure()方法。 那么子View根据什么来确定自己应该具有的尺寸呢？当然不可能让子View自由地决定自己的大小，父View必然需要向子View传递信息来帮助子View来确定尺寸，而子View则必须满足父View的要求。查看measure()的方法签名： 1public final void measure(int widthMeasureSpec, int heightMeasureSpec) 这里的widthMeasureSpec与heightMeasureSpec就是存储这一信息的参数。它们的类型是int，内部以高两位来存储测量的模式，低三十位为测量的大小，计算中使用了位运算来提高并优化效率。当然我们不必使用位运算来获得对应的数值，View.MeasureSpec为我们提供了对应的方法。 测量模式有三种： EXACTLY：精确值模式，即子View必须使用这一尺寸，并且保证它们的所有后代都在这个范围之内。当我们将控件的layout_width、layout_height属性指定为具体数值或match_parent时，系统使用这一模式。 UNSPECIFIED：无限制模式，不对子View施加任何限制，完全由子View决定自己的大小。可以用于查看子View想要的尺寸，比如可以把子View的长度使用EXACTLY模式限制在100，不限制宽度来查看子View在长度为100情况想要的宽度。 AT_MOST：最大值模式，只限制子View能具有的最大尺寸，子View必须保证它和它的后代们都在这一范围之内。 了解这些，我们就可以通过重写onMeasure()来确定一个View的尺寸。 但在重写方法时要注意：必须调用setMeasuredDimension() 来将最终尺寸存储在View中，否则会抛出一个IllegalStateException。 xml: 12345&lt;com.viseator.viewtest.VView android:layout_width="wrap_content" android:layout_height="100dp" android:background="@color/Gray" /&gt; VView: 1234567891011@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int width = MeasureSpec.getSize(widthMeasureSpec); int height = MeasureSpec.getSize(heightMeasureSpec); Log.d(TAG, "widthMode: " + widthMode); Log.d(TAG, "heightMode: " + heightMode); Log.d(TAG, "width :" + width); Log.d(TAG, "height :" + height); super.onMeasure(widthMeasureSpec, heightMeasureSpec); log: 这段简单的代码验证了之前的说法，分别对宽高设置了wrap_content和固定值，可以发现模式分别为AT_MOST与EXACTLY（以数值表示）。 这里输出的宽高值是以像素为单位的，可以看到高度的期望值就是设置的大小，但wrap_content期望的宽度值为1080（屏幕宽度），默认即为屏幕宽度，但最终计算得出的宽度值由于里面没有文字所以为0。 同样地，UNSPECIFIED模式给出的默认尺寸也是屏幕的宽/高。 所以我们可以看到如果想要实现wrap_content的效果，我们必须在onMeasure中对AT_MOST模式计算其内容宽/高并作为最终的宽/高，否则将以屏幕的宽/高进行填充。以LinearLayout的源码为例： 1234567891011121314151617181920212223242526272829if (useLargestChild &amp;&amp; (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123; mTotalLength = 0; for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); // Account for negative margins final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); &#125;&#125;// Add in our paddingmTotalLength += mPaddingTop + mPaddingBottom;int heightSize = mTotalLength; 这部分代码向我们展示了LinearLayout处理子View并计算所有的高度的情况。 知道了这个调用过程，我们就可以真正地进行onMeasure()的重写了。 例如可以暴力指定View尺寸： 1234@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(100,600);&#125; 可以为AT_MOST与UNSPECIFIED模式指定一个默认大小： 123456789101112131415@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measureSize(widthMeasureSpec), measureSize(heightMeasureSpec));&#125;int measureSize(int measureSpec) &#123; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); if (mode == MeasureSpec.EXACTLY) &#123; return size; &#125; else &#123; size = 300; //Default size return Math.min(size,MeasureSpec.getSize(measureSpec)); &#125;&#125; 至于更复杂的计算逻辑由于本人能力有限就不写demo了，如果以后实际中遇到需要的时候再作补充。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View绘制生命周期总览]]></title>
    <url>%2F2017%2F03%2F09%2Fandroid_view_lifeCycle%2F</url>
    <content type="text"><![CDATA[为了直观表示整个过程，我制作了一张流程图。注意以下只是整个生命周期中比较常用的方法，并不代表所有的过程。 当一个Activity收到焦点即将要处于激活状态时，将会被要求绘制它的布局，绘制布局之前的过程在这里不涉及，我们从绘制View开始分析。 每个Activity被要求提供一个ViewGroup作为View树的根，也就是我们熟悉的setContentView方法。 1234567891011121314@Overridepublic void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID);&#125;@Overridepublic void setContentView(View view) &#123; getDelegate().setContentView(view);&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; getDelegate().setContentView(view, params);&#125; 可以看到setContentView拥有三种形式，可以直接传入View、传入一个layout资源文件，或传入一个View文件和一个用于提供参数的LayoutParams对象。 整个过程将从这个根View开始，并遍历它的子View来逐一绘制，每个ViewGroup承担了要求它的子View进行绘制的责任，每个View承担了绘制自身的责任。并且父View会在子View完成绘制之前进行绘制，同级的View将以它们出现在树中的顺序进行绘制。 首先调用的当然是View的构造函数，构造函数分为两种，一种供代码创建的View使用，另一种是由layout文件生成的View使用，区别在于后者会从layout文件中读入所有的属性，前者的属性则需要在代码中设置。 另外后者在所有的子View都生成完毕之后会回调onFinishInflate方法。 在正式绘制之前要进行两个过程（布局机制[layout mechanism]）： 首先是measure过程。这是一个自顶向下的过程，父View将期望尺寸传递给子View，子View需要根据这一信息确定自己的尺寸，并且保证这一尺寸满足父View对其的要求，在子View确定自己尺寸的过程中也要向它的子View传递信息，就这样递归地确定自己的尺寸信息并储存在自身中，保证在measure方法返回时，自身的尺寸信息已经确定。所以在根View的measure方法返回时，所有子View的尺寸信息已经全部确定了。 这个过程需要注意一个View可能不止一次地调用measure方法来对子View进行测量。比如，可能要先传递一个无限制的信息来获取子View想要的尺寸，当子View希望的尺寸过大或过小时，父View需要再次调用measure方法来给予子View一些限制。 第二个是layout过程，这也是一个自顶向下的遍历过程，在这个过程中父View负责按照上一个过程中计算并储存在View中的尺寸信息来正确地放置子View。 同时这个过程可以通过调用requestLayout()来重新进行，并且会引起后面步骤的执行，相当于对以这个View为根的View树进行重新布局。 下面就是真正的绘制过程了，也就是View的draw()方法，在draw()方法中，（如果需要）会依次调用如下方法： drawBackground()：在画布上绘制特定的背景 onDraw()：重写View几乎必重写的一个方法，用于绘制图形 dispatchDraw()：ViewGroup会重写这个方法，用于对所有的子View调用draw()方法进行绘制 onDrawForeground()：用于绘制前景（如果需要） 可以看到如果需要调用上述的方法必定会按照这个顺序进行，也就是说，子View的绘制是在父View绘制之后进行的，而同级View的绘制是根据View在父View中的顺序进行绘制的。 同时这个过程可以通过调用invalidate()来重新进行，相当于进行某个View的重绘。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>LifeCycle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型中List、List&lt;Object&gt;、List&lt;?&gt;的区别]]></title>
    <url>%2F2017%2F02%2F14%2FDiffInGeneric%2F</url>
    <content type="text"><![CDATA[Java 1.5中引入了泛型的概念以增加代码的安全性与清晰度，同时为了提供对旧代码的兼容性，让旧代码不经过改动也可以在新版本中运行，Java提供了原生态类型（或称原始类型）。但是实际中在新的代码中已经不应该使用原生态类型。 原生态类型的含义是不带任何实际参数的泛型名称，例如Java 1.5后改为泛型实现的List&lt;E&gt;，List就是它的原生态类型，与没有引入泛型之前的类型完全一致。 而在虚拟机层面上，是没有泛型这一概念的——所有对象都属于普通类。在编译时，所有的泛型类都会被视为原生态类型。 那么为什么不应该使用原生态类型呢？ 如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。——Effective Java 泛型的目的简单地说就是可以让一些运行时才能发现的错误可以在编译期间就可以被编译器所检测出，运行时出问题的代价与编译期出现问题的代价的差别可想而知。换句话说，泛型是编译器的一种及时发现错误的机制，同时也给用户带来了代码的清晰与简洁的附加好处（不必再写一些复杂而危险并且不直观的强制类型转换）。 下面就进入正题谈谈以List为例时List、List&lt;Object&gt;、List&lt;?&gt;的区别。 先下定义： List：原生态类型 List&lt;Object&gt;：参数化的类型，表明List中可以容纳任意类型的对象 List&lt;?&gt;：无限定通配符类型，表示只能包含某一种未知对象类型 下面看一段代码： 1234567public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); List list = strings;//ok List&lt;Object&gt; objects = strings;//Error: java: incompatible types: java.util.List&lt;java.lang.String&gt; cannot be converted to java.util.List&lt;java.lang.Object&gt; &#125;&#125; 我们创建了一个List&lt;String&gt;类型的对象strings，再把它赋给原生态类型List，这是可以的。但是第5行中尝试把它传递给List&lt;Object&gt;时，出现了一个类型不相容错误，注意，这是一个编译期错误。 这是因为泛型有子类型化的规则： List&lt;String&gt;是原生态类型List的一个子类型。虽然String是Object的子类型，但是由于泛型是不可协变的，List&lt;String&gt;并不是List&lt;Object&gt;的子类型，所以这里的传递无法通过编译。 如果像上面那样使用原生态类型会有什么隐患呢？看下面一段代码： 1234567891011public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); unsafeAdd(strings, (Integer)1); System.out.println(strings.get(0)); &#125; private static void unsafeAdd(List list, Object object) &#123; list.add(object); &#125;&#125; 编译器提示了两条警告： 第8行： 123456warning: [rawtypes] found raw type: List private static void unsafeAdd(List list, Object object) &#123; ^ missing type arguments for generic class List&lt;E&gt; where E is a type-variable: E extends Object declared in interface List 警告发现了原生态类型List，同时还贴心地指出了List&lt;E&gt;的形式以及E的来源。 第9行： 12345warning: [unchecked] unchecked call to add(E) as a member of the raw type List list.add(object); ^ where E is a type-variable: E extends Object declared in interface List 同样指出了我们正在把一个对象添加到List中，而这个添加过程由于我们使用了原生态类型而无法被检验。 如果忽略这两条警告并运行这个程序，显然会出现一条错误： 第5行： 1Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 我们试图把一个自动装箱后的Integer对象插入到了一个被声明为List&lt;String&gt;的List中，由于我们在unsafeAdd方法中使用了原生态类型，从而使得编译器无法在编译期间检查add参数的合法性，从而没有产生编译错误而是产生了一条警告，运行后当试图把这个错误的Integer对象作为String取出时就会出现ClassCaseException异常，这是个运行时的异常，导致了程序中断。 如果我们把unsafeAdd方法的参数从List改为List&lt;Object&gt;会发生什么呢？正如之前所说的那样，由于List&lt;String&gt;并不是List&lt;Object&gt;的子类型，所以在传递参数的时候就会出现第一段代码中出现的编译期错误。这体现了泛型所带来的安全性。 可以这么说，List&lt;Object&gt;唯一特殊的地方只是Object是所有类型的超类，由于泛型的不可协变性，它只能表示List中可以容纳所有类型的对象，却不能表示任何参数类型的List&lt;E&gt;。 而List&lt;?&gt;则是通配符类型中的一种特例，它并没有extend或super这样的限制，从而可以做到引用任意参数类型的List&lt;E&gt;。但由于没有表示类型的符号（E），在方法中无法引用这个类型，所以它只用于无需使用具体类型的方法之中，如果不是这个情况，则需要使用泛型方法（只用List&lt;?&gt;的不是一个泛型方法，它具有List&lt;?&gt;这个固定的参数`）。 但是List&lt;?&gt;还是不能用作上面的unsafeAdd的参数，修改后会出现一条奇怪的编译错误： 123456789error: no suitable method found for add(Object) list.add(object); ^ method Collection.add(CAP#1) is not applicable (argument mismatch; Object cannot be converted to CAP#1) method List.add(CAP#1) is not applicable (argument mismatch; Object cannot be converted to CAP#1) where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ? 这是因为无法将任何元素（null除外）放入List&lt;?&gt;中。这又是为什么呢？先来看一个有限定通配符的例子： 123456789public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;(); numbers= new ArrayList&lt;Double&gt;(); numbers= new ArrayList&lt;Float&gt;(); numbers = new ArrayList&lt;Number&gt;(); numbers.add(new Integer(1)); &#125;&#125; 第7行报出了与之前相似的编译错误： 123456789error: no suitable method found for add(Integer) numbers.add(new Integer(1)); ^ method Collection.add(CAP#1) is not applicable (argument mismatch; Integer cannot be converted to CAP#1) method List.add(CAP#1) is not applicable (argument mismatch; Integer cannot be converted to CAP#1) where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends Number 这次我们可以看出错误的原因：可以将一个List&lt;Integer&gt;传递给List&lt;? extends Number&gt;，因为Integer是Number的子类，符合限定符的条件。同理，也可以将类似的对象传递给它，当然也可以把List&lt;Number&gt;传递给它。 如果允许这个对象的add操作，我们无法知道这个参数是否与对象的泛型参数相同，因为我们只知道它是Number的一个子类。 123List&lt;? extends Parent&gt; list = new ArrayList&lt;Child&gt;();List&lt;? extends Parent&gt; parents = list;list.add(new Parent()); 上面的1,2两行是完全合法的，如果允许第3行的add操作，那么会把一个Parent对象加入到一个实际类型是Child的List中，而Parentis-not-a Child，这破坏了Java的类型安全，是绝对不允许的。 上面是有限制通配符的情况，那么针对List&lt;?&gt;这样的无限制通配符更是如此。因此，为了保证类型安全，不允许对List&lt;?&gt;或List&lt;? extends E&gt;这样的通配符类型进行类似add的操作。 使用泛型方法可以避免这个问题（重申通配符类型并不是泛型方法），使用无限制通配符类型可以取代其他需要表示包含某一种对象类型的泛型类型的情况而不是使用原生态类型List。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode踩坑集锦]]></title>
    <url>%2F2017%2F02%2F05%2FLeetCode%2F</url>
    <content type="text"><![CDATA[写在前面寒假（假装）看完《数据结构与算法分析》之后决定是时候开始做LeetCode的题目了，在这里记录下一些LeetCode过程中遇到的坑，做LeetCode不仅是对算法的一种考验，也是对Java基础知识的一种考查，在Java基础并不是太好的现在做一定会漏洞百出，在这里统一做一个记录，也会写下对一些题目的想法。 LeetCodeTwo Sum直观上的方法是遍历所有元素对找出答案，看了解答以后发现可以用Hash表实现，Hash表可以进行对另一个元素的快速查找并返回对应的位置。 12345678910111213public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (Integer num : map.keySet()) &#123; if (map.containsKey(target - num) &amp;&amp; !Objects.equals(map.get(num), map.get(target - num))) &#123; return new int[]&#123;map.get(num), map.get(target - num)&#125;; &#125; &#125; return null;&#125; 上面的代码在用例[3,3] 6的时候返回结果为null，原因是第7行中第二个判断条件不成立，由于构建hash表的时候后面一个[3,1]覆盖了前面的[3,0]导致无法同时找到两个位置。（提醒了hash表一对一的性质，后面加入的元素如果key相同会覆盖前面的元素） 解决办法是不遍历key而是直接遍历nums数组，比较循环的索引和hash表的value，这样可以保证找到对应的那个位置不同的元素位置。 Rotate Array12345678910public static void rotate(int[] nums, int k) &#123; for (int i = 0; i &lt; k; i++) &#123; int[] temp = new int[nums.length]; temp[0] = nums[nums.length - 1]; for (int j = 0; j &lt; nums.length-1; j++) &#123; temp[j + 1] = nums[j]; &#125; nums = temp; &#125;&#125; 错误的原因是没有理解数组元素传递的本质是对数组对象引用的值传递，刚开始看到这题目觉得怎么可以用java做，java都是值传递无法改变原来数组。上面的做法的结果是把一个新的数组对象的引用赋给了nums的一个拷贝，但是原来的nums并没有引用到新的地址，所以原nums还是保持不变。 查了相关资料了解到数组元素的传递与对象一样（数组也可以看成new int[]产生的对象），传递的是数组的引用的拷贝，可以通过这个引用来修改原数组的数据。]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年度总结]]></title>
    <url>%2F2017%2F01%2F20%2F2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2016年度总结写在前面许多人在跟我聊天的时候感慨，时间怎么过得这么快，不知不觉自己就是二十多的人了，过几年就要奔三了。相反地，我却觉得时间过得却不是那么快，因为自己确实在随着时间而改变，而且这样的改变是自己实实在在可以感受到的。从初中开始过来的这几年，可以说是一年一个样子，每次翻看自己一年前写的东西都会看到当时的幼稚与无知，自己也有着许许多多的习惯、看法、认识在随着时间推移在改变着。 而2016年是对身边每一个像我一样的新生都十分关键的一年，经历了身份、时空的转变，带来的是各种观念的迅速变化，但感到庆幸的是我并不惧怕改变。 这大概就是这段时间的必然，我们在快速成长着，不断地丢下之前的想法，不断获取新的东西与认知，不知道这样的改变还会持续多久，但是可以确定的是我确实是在朝着对的方向成长着。 之前的习惯是在每年生日的时候写下一些东西作为记录，但是今年因为忙碌而落下了，在学期结束的时候正好自己所在的两个团队都要求有一篇总结，虽然分别是年度的和学期的，我还是一并写成年度的，大概高中时期的那些种种在现在看来毕竟是过去了，所以这篇总结会分成两部分，先是来华科前的时期，主要内容在来华科后的时期。作为一篇写给别人看的总结就不包含那些生活上的东西了。 高中似乎身边每一个人说起自己的高三时光，都是无尽的考试和补课，和最终那一次高考的种种经历。在这个明确的人生分水岭之前，每个人都不得不正视自己的成绩。 但奇怪（或许不）的是，我对高中的印象却完完全全没有上面说的那些东西，因为它们都随着高考的结束而截止了。我能记住的只有高中生活中那些无关于学习的那些，那些在高三的忙碌中偷得的闲暇，那些三年来朝夕相处的珍贵。 而成绩与最后的结果，现在看来都是一种必然，无论最终的结果如何，都会有一种方式让我好好珍视现在，像高中语文老师寄言的那样：人生的每个阶段都会有每个阶段的痛苦与快乐。 我不曾为自己之前做过的任何一个决定后悔过，它们的结果或已变成好的那方面，或已不再重要。性格如此，我只关注现在的事情，过去的事情会很快放下，从而尽快找到一种适合的方式好好面对当下的那些或好或坏的事情。 在高中时期没有想过自己一定会去哪一个学校，但直觉告诉我一定会有一条路在那里等着我，我没有计划过高考要考多少分，也没有拼命地为了所谓的不浪费去各种揣度志愿应该怎么填，在高中的最后阶段，支持着我的是再也不以分数高低论断一个人的成败的未来和学习真正愿意为之付出精力的东西。 最令我感到幸运的是我在很早的时候我就知道愿意去为什么付出自己的热血，这讲起来又是另一个故事了，但是从我有大学专业这个概念以来，我从来没有考虑过除计算机相关以外的任何一个专业。所以在暑假高考成绩出来的那一刻起华科就成了我最好且是唯一的选择。我的志愿在系统开放十分钟以内就填好了，我想这就是我前面所说的那种必然。 华科来华科以后的生活似乎就成变多线程的了，加入了很多的学生组织，一度让我在时间安排上感到非常爆炸，但是不管怎么样接下的锅我都会好好背到底的。对来华科以后这段时间的总结就按身份不同分成几个方面吧。 联创团队关于华科的一切就是从那时开始了解的，而对于华科的三大团队网上很高的评价和咨询群中表现出来的态度就足够令人向往，而令一方面也让我对自己的水平心生怀疑，虽然早就有学计算机的打算但之前却没有条件让我在这条路上更深一步，这样的心态甚至让我一度在联创招新的时候不敢去投出一份所谓的简历。正如那时所说的那样，我深知自己的水平还不足以加入联创，但是我却有了去提升自己的欲望和前进的动力。 当时在招新快要结束的时候正好班主任（大四学长）来我寝室，闲聊中我说起报名这事，他表示：报个名又不会有什么损失，为什么不试一试呢？现在看来那时候我的心态确实很奇怪，想去追求的东西因为担心自己的能力连第一步都不敢踏出，大概是太过于担心自己会失败吧。 所以在离报名截止还有两天的时候我同时报了联创和冰岩的名，第一次面试是冰岩的一面，因为太过紧张以至于语无论次，讲起来也没有什么逻辑。面试以后就觉得自己跪了。之后是联创的笔试，只知道Android会考Java，所以提前一天买了本Java书看，本来也没有对笔试抱多大的希望，题目里面关于面向对象的内容还是根据之前看过的C++的那套东西答的。所以在后面收到二面通知的时候还是觉得十分惊喜的。 面试我的是朱一百和王启萌，记得那天我们聊的挺开心的，也是我第一次看到808，那时候第一次感觉到自己离这样一个团队这么近。之后给了三个礼拜的时间准备熬测，正好国庆放假，把买的Java和Android的书带回去用最快的速度看，感觉那样这么用心地为了一个目标努力的时候真是非常难得。 再之后的事情似乎又在意料之内了，越到后面越感到自己能实现这件事，所以这件事也就这样实现了。 联创的一切也如同我想的那样，有一群志同道合的伙伴和各种方面都非常强的聚聚学长。加入联创的第一个收获就是让我能看到更大的世界是什么样子，知道同龄的人可以做到什么样子，更重要的是，他们就在我身边。这样的氛围我想在其他的任何地方都很难找到。 实习三个多月，从第一个礼拜没有安卓基础写出第一个APP，接到第一个Java项目，到组队一起写出一个游戏打比赛，再到自己去实现自己的一些想法，其中的成长不言而喻。 做APP的过程其实在DR里面已经有记录，在这里就不一一细数。总的看来，有一些收获对我以后的学习有着很大的帮助： 学会使用Google，习惯在英文环境下解决问题，从一开始对满屏的英文不知所措到后面可以筛选出自己想要的信息，对我的英语能力也是一种提升。（感谢Mentor顺手改的搜索结果显示语言） 看文档写代码而不是看Demo跟着写，一开始遇到不会实现的东西都是先找别人的实现再套用到自己的情境中，后来明白官方提供的文档就是最好的参考资料，虽然有些时候看Demo写可以更快的实现，但是回过头来看看文档总能发现一些新东西从而加强自己的理解。毕竟只有自己写出来的东西才是自己的。 讲究代码的规范性问题。这一点Mentor在对我代码的Review中反复强调了很多次，希望我从一开始就养成好的习惯。 熟悉自己的操作环境，提高效率。花了非常多的时间来折腾Linux，目的就是为了给自己一个可以排除其他干扰高效率地工作的环境。熟悉各种快捷键和插件也是锻炼的一部分。 重视基础。有很多前辈告诉我基础内容非常重要，尤其是像数据结构、算法这样的内容看似平常用不到，但是关键时候看的往往就是这样的基本功。所以我开始想去花一些时间认真地静下心来补一补这些基础内容。 开始写博客来记录一些东西。建了自己的博客，虽然现在只有手头项目相关的三篇博文，很大一部分原因是我认为博文内容一定要是自己理解比较深刻的一些东西才值得写。目前自己水平不高的情况下瞎写一些东西也没有什么价值，应该在之后某个时候觉得自己对某个东西有自己的理解的时候才会好好地把这些分享给别人吧。 Git与团队合作，目前合作的两个项目都是通过git完成的，一开始用git出现了很多问题但是到后面熟悉以后就可以好好利用git的功能了。 其实学到的东西远不止上面总结的这些，很多东西都是从与其他人的接触中慢慢学会的，总之很荣幸可以接触到这个学校最优秀的一群人。 班长大学接下班长职务是想发挥一下自己搞事的天赋，希望能够通过自己的一些行动去为大家做一些事情。平时给同学、班委开会也是对自己的锻炼。感谢在最忙的那些时候有其他的班委主动帮我分担。班上有一群可爱的同学们，虽然说大学同学不似高中那样朝夕相处，但是我希望大家可以一起留下一些美好的回忆。 美团点评技术俱乐部一开始自己对学生组织的打算是一个技术团队和学生组织。因为暑假水群的时候就跟安祺和负责科创的大叔聊过，开学俱乐部招新的时候也跟安祺大叔简单聊了一下，于是就来了刚成立的美团。 因为美团刚成立成员也特别少，所以大家很快就熟悉了， 美团的群也成了我们日常闲扯的地方。而学院今年为科创的各个俱乐部新装修的场地也就在我寝室的顶楼，对于我们来说是一个大福利了。 后来通过学院接到的自己和唐艺峰合作的第一个项目，做一个表格内容识别的东西。在那个时候我才刚有一些Java基础，在想接不接的时候又想起了自己考虑报不报联创一样的情景。这次我没有太多犹豫，一是大一就有可能接到项目做很难得，二是项目对自己的锻炼也是非常大的，不给自己一些压力就不会做成一些事情。 这个项目中间虽然经历了很多日常的绝望，像前辈说的那样踩过了很多的坑，例如PM改需求，但是到最后总算是把第一期完成了，过程中也有了自己三篇博文。 后面学院又跟企业合作拿到了一批新的项目，估计下学期会开始做。在科创这边的活动有学院的支持以后在项目方面就有了保证。希望俱乐部这边能在学院的支持下可以好好发展。 学生会宣传部正如招新的时候所说的，学生会是一个大家庭，在宣传部认识了很多非常可爱的学姐和学长，也结识了一些跟我同届的部员们。 宣传部做出来的东西是实实在在可以被大家看到和关注的，看到自己做出来的海报被贴出来的感觉真的非常好。尝试了第一次用比较长的一段时间用心做一张真正意义上的海报，第一次用AE撸出第一个视频被大家转发。 宣传部的大家都很有爱（虽然群里总是gaygay的），但是每次问一些问题总会有人回答。例会的零食、部长的宅舞、圣诞的贺卡……这一切回忆起来总是那么温馨。 这个学期接的锅其实就一张海报，视频的活还没有开始接，自己也因为联创的事情鸽了一些活动。下学期会好好弥补的。 关于未来总结下来这一年的我似乎没有遇到什么太大的困难（或者说那些困难到现在看已经算不上了），一切都在向着充满希望的方向发展着。班主任曾对我们说过一句话：“大家都希望成为自己想要的样子，但是到最后大部分都成了自己愿意成为的样子。”计划总是赶不上变化的，我也是一个不善于计划的人，我对于自己未来的走向的改变总是在平时的一个个决定中促成的，好在现在看来还是走在应该走的路上。 从加入联创的那一刻起我已经决定不读研，知乎上看过一句话是：“大学把一件事做到牛逼才谈得上成功的大学生活。”那么我想这件事对于我一定是技术，有这样的氛围和条件让我去好好做这件事必然不会让我失望。我也希望自己能真正地专注在一件事情上。 虽然我不是一个理想主义者，但是现在的我是充满着希望的，因为我看到了我可以成为怎样的人，看到了未来的那些可能，知道了那样一部分自己的未来会是怎么一个样子。 但是不管自己的打算多么好，条件多么优越，始终不能变的是自己的努力，在这里也要告诫自己要Stay Hungry, Stay Foolish.时刻保持清醒，保持自知。 “你要克服的是你的虚荣心，是你的炫耀欲，你要对付的是你时刻想要出风头的小聪明。”——蔡千嬅 共勉。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV处理拍照表格（三）]]></title>
    <url>%2F2016%2F12%2F09%2FOpenCV%E5%A4%84%E7%90%86%E6%8B%8D%E7%85%A7%E8%A1%A8%E6%A0%BC%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[说明在开始说明直线检测过程前先作个说明，由于直线检测的算法需要遍历每个像素，所以总的耗时比较长，在安卓上跑的时候直线检测的时间可能会长达两分钟，这是在测试过程中不能接受的，所以我将安卓上的代码整个迁移到了Idea中，关于Idea中OpenCV的配置，可以参见这个教程。 这个步骤的目的：这步中我们会检测出整张图片中满足条件的所有直线，再通过筛选选出横的表格框线，再利用检测出的表格框线来提取两个框线之间的内容即为表格中的一行。 代码实现12345678910111213141516171819202122232425private void cutImagesToRows() &#123; ArrayList&lt;Double&gt; lineYs = new ArrayList&lt;&gt;(); ArrayList&lt;Double&gt; uniqueLineYs = new ArrayList&lt;&gt;(); //lines:a special mat for find lines Mat lines = new Mat(); //find lines and store in lines Imgproc.HoughLinesP(dilateMuchPic, lines, 1, Math.PI / 180, Y_THRESHOLD, Y_MINLINELENGTH, Y_MAXLINEGAP); //get the lines information from lines and store in lineYs for (int i = 0; i &lt; lines.rows(); i++) &#123; double[] points = lines.get(i, 0); double y1, y2; //just need the horizontal lines y1 = points[1]; y2 = points[3]; // if it slopes, get the average of them, store the y-coordinate if (Math.abs(y1 - y2) &lt; 30) &#123; lineYs.add((y1 + y2) / 2); &#125; &#125; getUniqueLines(lineYs, uniqueLineYs, 10); 上面的注释里面讲得比较清楚，另外有一些解释： 前面提到过HoughLinesP这个函数的第二个参数是一个特殊的Mat，也就是代码中的lines，它的col（列）的值为1，row（行）的值为检测出的所有直线 （这里要注意一下，我手上的书的这两个值正好相反，可能是标准不同，我这里用的是OpenCV 3.1）。每个row为一个double[4]，四个值分别对应着起始点的x,y坐标，终点的x,y坐标（图片的左上角为原点）。两个点连起来就是检测出的直线。可以看到这里我只取了1,3，对应的是起点和终点的y坐标。 if (Math.abs(y1 - y2) &lt; 30)这句判断的目的是过滤掉竖直的直线（起始点y坐标之差显然大于30），并且允许横线有一定的倾斜（起始点可以有30像素的差距）。找到这样的一对点后，把它们的y坐标取平均值存入一个数组中。 ​ 由于图片中一条直线的宽度不可能正好是一个像素，所以必然会出现一条直线检测出很多个y坐标的问题，下面这个方法就是为了找到这些多余的y坐标并取它们的平均值作为最终的y坐标。 getUniqueLines(lineYs, uniqueLineYs, 10);代码如下： 12345678910111213141516171819202122232425/** * filter the source coordinates, if some values are too close ,get the average of them * * @param src source coordinates list * @param dst destination coordinate list * @param minGap the minimum gap between coordinates */private void getUniqueLines(ArrayList&lt;Double&gt; src, ArrayList&lt;Double&gt; dst, int minGap) &#123; Collections.sort(src); //sort the source coordinates list for (int i = 0; i &lt; src.size(); i++) &#123; double sum = src.get(i); double num = 1; //when the distance between lines less than minGap, get the average of thema while (i != src.size() - 1 &amp;&amp; src.get(i + 1) - src.get(i) &lt; minGap) &#123; num++; sum = sum + src.get(i + 1); i++; &#125; if (num == 1) &#123; dst.add(src.get(i)); &#125; else &#123; dst.add(((sum / num))); &#125; &#125;&#125; minGap：直线间距阈值，间距小于这个值的直线被处理。 1234567891011121314151617181920blockImages = new ArrayList&lt;&gt;();for (int i = 0; i &lt; uniqueLineYs.size(); i++) &#123; Rect rect; double y = uniqueLineYs.get(i); //if not the last line if (i != uniqueLineYs.size() - 1) &#123; rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT), (int) (y + (uniqueLineYs.get(i + 1) - y) * PADDING_TOP_BOTTOM), (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)), (int) ((uniqueLineYs.get(i + 1) - y) * (1 - PADDING_TOP_BOTTOM * 2))); &#125; else &#123; //the last line rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT), (int) (y + (srcPic.height() - y) * PADDING_TOP_BOTTOM), (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)), (int) ((srcPic.height() - y) * (1 - PADDING_TOP_BOTTOM * 2))); &#125; //cut the source picture to cutMat Mat cutMat = new Mat(srcPic, rect); blockImages.add(cutMat); 这步就是切割了，blockImages就是存放切割后的行图像的ArrayList。 关于Rect：Rect对象表示一个区域，可以作为Mat的构造参数传入来为目标区域创造一个Mat副本。四个参数分别代表了区域起始点的x,y坐标，区域长度和区域高度。 可以看到这里我使用了一个PADDING参数，来规定切割时距规定边缘的距离来避免把一些表格的边线切到图像中影响OCR的识别。 至于上面一篇博客中最后的红线是测试时用 12345678910111213private void showMarkedLines(Mat src, ArrayList&lt;Double&gt; lines) &#123; Mat showLines = new Mat(); Imgproc.cvtColor(src, showLines, COLOR_GRAY2BGR); for (double y : lines) &#123; Point pt1 = new Point(0, y); Point pt2 = new Point(src.width(), y); Imgproc.line(showLines, pt1, pt2, new Scalar(0, 0, 255), 3); &#125; Imgcodecs.imwrite("C:/Users/visea/Desktop/test/java/cut/" + String.valueOf(colNum) + ".jpg", showLines);&#125; 打印出来的，这里新建了一个showLines并且把原图像通过Imgproc.cvtColor方法转换成BGR图像并复制到showLines（不转化成彩色格式只能显示灰度图像）。 打印一条直线也比较简单，只要新建两个Point对象代表起始点和终点，这里我把x坐标设置为图像的起始x坐标，y坐标为之前得到的唯一的y值，所以可以看到画出来的线就是水平并且从开头一直到结束的。 画直线使用Imgproc.line方法，最后两个参数依次是BGR三个通道的值组成的Scalar对象，代表直线的颜色，以及画出的直线的宽度（以像素为单位）。 效果最后用Imgcodecs.imwrite将Mat写入文件就可以看到最终的效果了，在测试的时候尤其有用。 也可以把blockImages中的图输出出来看结果，因为做的时候没存档，所以只能用之后的图来说明一下了： 请忽略图中的红线，为之后的步骤绘制出来的，左右不完整是因为我设置了百分之二十的左右的PADDING，为了方便后面的找线与切割。 当然在找直线的过程中也可以把找到的图片打印出来感觉一下效果，下面分别是调试前出的图和最终参数调试后出来的图： 调试前： 调试后：]]></content>
      <categories>
        <category>Java</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV处理拍照表格（二）]]></title>
    <url>%2F2016%2F12%2F02%2FOpenCV%E5%A4%84%E7%90%86%E6%8B%8D%E7%85%A7%E8%A1%A8%E6%A0%BC%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[先来看看上次处理后的整张图片效果： 这里发现我将图片的颜色已经反相了，这是考虑到下一步的直接检测必须以白色像素为内容。做法在上一篇提到过，交换两段的位置就可以了。 可以看到噪点已经几乎没有了，文字的清晰度还是可以的。这里采用的kernel都是2x2的。 直线检测下面就是比较关键步骤——直线检测了。 首先介绍一下openCV提供的直线检测算法：霍夫变换。 霍夫变换是图像处理中一个著名的检测算法，用于对二值图片中特定的几何形状的检测，直线检测只是其中比较常见的一种用法。从holybin的专栏中复制一段介绍基本理论的内容： Hough直线检测的基本理论是二值图像中的任何点都可能是一些候选直线集合的一部分，所选的参数方式是每一行代表极坐标中的一个点，并且隐含的直线是通过象征点的，垂直于原点到此点的半径，即：检测的过程可以看成从图像中的一个个像素点出发，寻找每个点成为直线一部分的可能，再把这条线上可能的点连起来形成直线。在实际检测中，当一条线出现凹陷或是弯曲度时，也会检测出直线，只是不是一条完整长度直线，而是断断续续重叠相近的很多直线。&gt;而对于图像中的一条直线而言，利用直角坐标系，可以表示为：的形式。那么，该直线上任意一点（x,y）变换到k-b参数空间将变成一个“点”。也就是说，将图像空间中所有的非零像素转换到k-b参数空间，那么它们将聚焦在一个点上。如此一来，参数空间中的一个局部峰值点就很有可能对应着原图像空间中的一条直线。不过，由于直线的斜率可能为无穷大，或者无穷小，那么，在k-b参数空间就不便于对直线进行刻画和描述。所以，研究人员提出采用极坐标参数空间进行直线检测。在极坐标系中，直线可以表述为以下形式：&gt; 更为详细的分析可以看浅墨的博客 如果不能理解也没有关系，在openCV中已经为我们封装成了两个函数HoughLines( )与HoughLinesP( )，他们之间的区别在于算法的不同，而效果的差别不大，但HoughLinesP可以减少计算量，所以在这里我们采用了HoughLinesP来进行。1public static void HoughLinesP(Mat image,Mat lines,double rho,double theta,int threshold,double minLineLength,double maxLineGap) Finds line segments in a binary image using the probabilistic Hough transform. Parameters:image - 8-bit, single-channel binary source image. The image may be modified by the function.lines - Output vector of lines. Each line is represented by a 4-element vector (x_1, y_1, x_2, y_2), where (x_1,y_1) and (x_2, y_2) are the ending points of each detected line segment.rho - Distance resolution of the accumulator in pixels.theta - Angle resolution of the accumulator in radians.threshold - Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt;threshold).minLineLength - Minimum line length. Line segments shorter than that are rejected.maxLineGap - Maximum allowed gap between points on the same line to link them. 解释一下各个参数： image:源图像 Mat格式，8位单通道（Cv_8UC1） lines: 输出的“图像” 虽然是Mat格式，但是其中保存的内容已经不再是图像了，其中的每行（Rows！在这里手上买到的一本书中写成了列，大概是因为版本不同导致的，因为这个在这里卡了好几个小时……）中储存了一个double[]，下面会讲到如何使用里面的信息。 rho：翻译过来是距离的解析度，以像素为单位，在后面这个参数起了大作用。 theta：与rho相似地，是角度的解析度，以弧度为单位。 threshold：阈值 这个值决定了霍夫变换后对于一对值投票所需达到的阈值才能被记录。换句话说，这个值越大，检测出直线的要求就越高（这个要求应该是对于直线上的点聚集程度的要求）。应为一个非负值。 minLineLength:字面意思，检测出的直线的最小长度，小于这个长度的直线将不会被记录。单位是像素。 maxLineGap：字面意思，检测时可以接受的直线断开的距离（实际情况中很难达到一条直线上的点全部都有，通常是断断续续的，这时这个值就发挥了很大的作用）。单位是像素。 可以看到这个函数的参数非常多，并且有个别参数并没有一个量化的标准（比如threshold在检测大图的时候取150左右的值比较好，但在后面检测小图时候设成0都不尽人意，rho与theta参数如果按照资料中普遍的1和2pi/180来设置小图的检测就会出现问题），更加悲惨的是这些参数之间存在相互影响，对实际的图片进行处理的过程中参数的差别可能很大，需要一些耐心和方法去慢慢调试（我写了嵌套的循环再输出所有的图用肉眼看效果再缩小范围……） 最影响最终效果的部分在于最后两个值的设置，可以看到上面我们将要处理的图片，这步我的目的是检测出所有的横向的表格边线。下面先上最终的效果图： (红线为最终检测出的直线位置） 具体的检测过程下一篇介绍。]]></content>
      <categories>
        <category>Java</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV处理拍照表格（一）]]></title>
    <url>%2F2016%2F11%2F15%2FOpenCV%E5%A4%84%E7%90%86%E6%8B%8D%E7%85%A7%E8%A1%A8%E6%A0%BC%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境配置https://www.learn2crack.com/2016/03/setup-opencv-sdk-android-studio.html 非常新的一篇在AS中安装OpenCV的教程，按教程装好了环境并测试通过。 注意教程中没有讲到的是想要使用OpenCV的相关功能，需要安装下载包中apk目录下的对应处理器的OpenCV manager。并在使用OpenCV的活动中加入以下内容：1234567891011121314151617private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; //Connect to OpenCV manager service and initialize @Override public void onManagerConnected(int status) &#123; switch (status)&#123; case BaseLoaderCallback.SUCCESS: Log.i(TAG, "OpenCV Success"); break; default: super.onManagerConnected(status); Log.i(TAG, "OpenCV Fail"); break; &#125; &#125;&#125;; 1234567//Initialize at every resume@Overrideprotected void onResume() &#123; super.onResume(); OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_1_0, getApplicationContext(), mLoaderCallback); Log.d(TAG, "On Resume OK");&#125; http://docs.opencv.org/java/3.1.0/&gt;opencv的官方文档。更正：上面的3.1版的文档并没有详细的方法解释！ 所以只能看 http://docs.opencv.org/java/2.4.11/ 2.4.11的。 处理的大致思路目前想到的思路是： 图像彩色转灰度 灰度图像设置阈值后二值化即变成完全黑白 去除多余的噪点 边缘识别 透视变形 矩形识别 分割识别出的矩形 OCR对矩形进行识别，读取数据。 实现灰度与二值化开始采用OpenCV中BitmapToMat方法，将文件以Bitmap的形式读取，再转换为Mat格式再进行处理。 后面发现了OpenCV自带的imread方法，传入文件路径和Mat的格式后就可以方便地获得一个Mat对象。 另外如果在这里采用Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE标签，就可以直接以灰度的形式读取图像，省去了颜色转化的步骤。并且这个Mat的格式就是下面一步二值化要求传入的8UC1（8位单通道）格式。 下面就是二值化步骤，OpenCV提供了两个函数，第一个是普通的Threshold函数： thresholdpublic static double threshold(Mat src,Mat dst,double thresh,double maxval,int type) Parameters: src - input array (single-channel, 8-bit or 32-bit floating point). dst - output array of the same size and type as src. thresh - threshold value. maxval - maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types. type - thresholding type (see the details below). 传入图像，传出图像，阈值，填充的最深颜色，填充方法（达到阈值就填充最深颜色或相反），就可以根据每个像素的灰度值与阈值进行比较来决定填充的值为0或是最深。 定阈值的方法虽然可以对一张图像通过调整达到最优的效果，但是对于不同光照条件下拍摄出来的照片，因为整体亮度的不同，定阈值显然无法适应所有的情况。 所以就有了第二种函数，adaptiveThreshold，除了传入上面的这些参数外，增加了三个重要的参数 adaptiveThresholdpublic static void adaptiveThreshold(Mat src,Mat dst,double maxValue,int adaptiveMethod,int thresholdType,int blockSize,double C)Parameters:src - Source 8-bit single-channel image.dst - Destination image of the same size and the same type as src.maxValue - Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.adaptiveMethod - Adaptive thresholding algorithm to use, ADAPTIVE_THRESH_MEAN_C or ADAPTIVE_THRESH_GAUSSIAN_C. See the details below.thresholdType - Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV.blockSize - Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.C - Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well. blockSize：对某个像素周围进行采样的范围。adaptiveMethod：根据上面的范围求阈值的方法，有两种： mean平均，简单地取采样范围内的平均值作为阈值。 gaussian高斯，以高斯函数为基础，简单地说就是近的地方权重更高、远的地方权重低，来求阈值。 C：求出来的阈值减去的常量。 这三个参数就是决定二值化效果的关键，我找最优值的方法比较暴力，写了一个嵌套的循环设置这两个值，再输出到文件导出到电脑上用肉眼比较。最后确定的值为17-10。 adaptiveMethod我用的是mean，因为表格相对来说黑白比较明显，并不需要去根据距离的远近来决定阈值。 17这个值在我的手机拍摄出来的效果里面是最好的，但由于不同拍摄设备的分辨率不同，就造成了笔画所占据的像素的数量的不同，可以想到的是在高分辨率的情况下这个值应该要相应地增大，打个比方说我一个笔画的粗细就有17个像素，那么这个范围内检测出的阈值就会非常高从而导致笔画的残缺不全。 C这个值还是需要经过测试来得出的，设置的不同对最后效果的影响是最大的，直接会决定最后出来的图片是笔画过粗或是笔画残缺。 下面是处理前后的效果： 可以看到二值化以后的图像只有黑白两色，但是明显有许多的噪点。 去噪二值化之后就是去噪了，去噪的目的是把图像中的独立的点去掉。 去噪的方法是腐蚀，跟字面意思一样，就是缩小图案的范围，当图像的范围本身就很小时（噪点就是一个个这样的独立点），缩小后自然就不见了。 可以想到，在去噪后，部分笔画也随之缩小甚至细的地方会直接消失，所以腐蚀之后要再进行一步膨胀，即把图案的边缘扩大。 因为噪点已经消失，所以也不会因扩大而回来，但笔画依然存在，就会膨胀而得到弥补，也顺便可以补一下残缺的地方。 原理大概就是这样，但是由于OpenCV的这两个操作针对的是图像中的亮点（白色的地方被认为是亮点），而我们的表格又是白底黑字的，实际上黑色的部分是我们想要处理的部分，所以我将这两步交换了，相当于是对黑色的地方先腐蚀后膨胀。 下面是代码实现：123456Mat kernelDilate = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(2, 2));Imgproc.dilate(srcPic, srcPic, kernelDilate);Imgcodecs.imwrite("/storage/sdcard/pic/test/afterErode.jpg", srcPic);Mat kernelErode = Imgproc.getStructuringElement(Imgproc.MORPH_ERODE, new Size(2, 2));Imgproc.erode(srcPic, srcPic, kernelErode);Imgcodecs.imwrite("/storage/sdcard/pic/test/afterDilate.jpg", srcPic); 参数中有一个Kernel，这个就是处理图像的核，具体的内容不展开，我们利用getStructuringElement函数可以构建特定的处理核，这个函数第一个参数是构建的核的类型，除了用于代码中用到的膨胀和腐蚀的类型，还有ract、cross、ellipse等不同的形状，后面的size就是我们设置的重点了，指的是核的大小，可以理解成检测的范围，对于大的噪点自然需要大的范围，但是也意味着笔画细节丢失也更加严重。对于膨胀操作，则可以理解成膨胀的像素数，这个数值越大，最后的结果中的笔画也就越粗。 下面是上述代码的结果对比： 之前 设置了四种不同的参数，可以看到噪点基本都被去除，最后的细节不尽相同。]]></content>
      <categories>
        <category>Java</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
</search>